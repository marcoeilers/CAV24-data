domain Address  {
  
  function field_address$$struct$m_LinkedList$$$f$val(_0: Address): Address 
  
  function field_address$$struct$m_LinkedList$$$f$next(_0: Address): Address 
  
  function field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(_0: Address): Address 
  
  function variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(_0: Address): Address 
  
  function variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(_0: Address): Address 
  
  function field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(_0: Address): Address 
}

domain Bytes  {
  
  
}

domain FunctionGas  {
  
  function function_no_gas$(): FunctionGas 
  
  function function_gas_level$(_0: FunctionGas): FunctionGas 
}

domain Functions  {
  
  function m_LinkedList$$len$(_0: Snap$ref$Shared$struct$m_LinkedList$, _1: FunctionGas): Snap$Unbounded 
  
  function m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_0: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$,
  _1: FunctionGas): Snap$ref$Shared$struct$m_LinkedList$ 
  
  axiom m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$$definitional_axiom {
    (forall _1: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$,
    gas$: FunctionGas ::
      { m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1,
      function_gas_level$(gas$)) }
      (valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(_1) ==>
      valid$Snap$ref$Shared$struct$m_LinkedList$(m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1,
      function_gas_level$(gas$)))) &&
      m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1, function_gas_level$(gas$)) ==
      m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1, gas$))
  }
  
  axiom m_LinkedList$$len$$definitional_axiom {
    (forall _1: Snap$ref$Shared$struct$m_LinkedList$, gas$: FunctionGas ::
      { m_LinkedList$$len$(_1, function_gas_level$(gas$)) }
      (valid$Snap$ref$Shared$struct$m_LinkedList$(_1) ==>
      m_LinkedList$$len$(_1, function_gas_level$(gas$)) ==
      (destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Isize(constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(destructor$Snap$struct$m_LinkedList$$$f$next(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1)))))),
      constructor$Snap$Isize$(0))) ?
        constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1))) :
        constructor$Snap$Unbounded$Add_Unbounded(m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(destructor$Snap$struct$m_LinkedList$$$f$next(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1))))))))),
        gas$))), gas$), constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1))))) &&
      (destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(m_LinkedList$$len$(_1,
      function_gas_level$(gas$)), constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1))))) &&
      valid$Snap$Unbounded(m_LinkedList$$len$(_1, function_gas_level$(gas$))))) &&
      m_LinkedList$$len$(_1, function_gas_level$(gas$)) ==
      m_LinkedList$$len$(_1, gas$))
  }
}

domain Lifetime  {
  
  function included(_0: Lifetime, _1: Lifetime): Bool 
  
  function intersect(_0: Set[Lifetime]): Lifetime 
  
  axiom included_in_itself$ {
    (forall lft: Lifetime :: { included(lft, lft) } included(lft, lft))
  }
  
  axiom included_intersect$1 {
    (forall lft_1: Set[Lifetime], lft_2: Set[Lifetime] ::
      { included(intersect(lft_1), intersect(lft_2)) }
      included(intersect(lft_1), intersect(lft_2)) == (lft_2 subset lft_1))
  }
  
  axiom included_intersect$2 {
    (forall lft_1: Set[Lifetime], lft_2: Lifetime ::
      { included(intersect(lft_1), lft_2) }
      included(intersect(lft_1), lft_2) == (lft_2 in lft_1))
  }
  
  axiom intersect_singleton$ {
    (forall lft: Lifetime ::
      { intersect(Set(lft)) }
      intersect(Set(lft)) == lft)
  }
}

domain MarkerCalls  {
  
  function basic_block_marker$start_label$marker(): Bool 
  
  function basic_block_marker$label_entry$marker(): Bool 
  
  function basic_block_marker$label_bb0$marker(): Bool 
  
  function basic_block_marker$label_bb1$marker(): Bool 
  
  function basic_block_marker$label_bb2$marker(): Bool 
  
  function basic_block_marker$label_3_custom$marker(): Bool 
  
  function basic_block_marker$label_bb3$marker(): Bool 
  
  function basic_block_marker$label_bb4$marker(): Bool 
  
  function basic_block_marker$label_2_custom$marker(): Bool 
  
  function basic_block_marker$label_bb5$marker(): Bool 
  
  function basic_block_marker$label_bb7$marker(): Bool 
  
  function basic_block_marker$label_bb8$marker(): Bool 
  
  function basic_block_marker$label_bb10$marker(): Bool 
  
  function basic_block_marker$label_bb11$marker(): Bool 
  
  function basic_block_marker$label_7_custom$marker(): Bool 
  
  function basic_block_marker$label_bb14$marker(): Bool 
  
  function basic_block_marker$label_6_custom$marker(): Bool 
  
  function basic_block_marker$label_bb13$marker(): Bool 
  
  function basic_block_marker$label_9_custom$marker(): Bool 
  
  function basic_block_marker$label_bb19$marker(): Bool 
  
  function basic_block_marker$label_bb20$marker(): Bool 
  
  function basic_block_marker$label_bb21$marker(): Bool 
  
  function basic_block_marker$label_5_custom$marker(): Bool 
  
  function basic_block_marker$label_bb12$marker(): Bool 
  
  function basic_block_marker$label_bb15$marker(): Bool 
  
  function basic_block_marker$label_bb17$marker(): Bool 
  
  function basic_block_marker$label_bb18$marker(): Bool 
  
  function basic_block_marker$label_13_custom$marker(): Bool 
  
  function basic_block_marker$label_12_custom$marker(): Bool 
  
  function basic_block_marker$label_bb22$marker(): Bool 
  
  function basic_block_marker$label_bb23$marker(): Bool 
  
  function basic_block_marker$return_label$marker(): Bool 
  
  function basic_block_marker$label_10_custom$marker(): Bool 
  
  function basic_block_marker$label_bb24$marker(): Bool 
  
  function basic_block_marker$resume_panic_label$marker(): Bool 
  
  function basic_block_marker$end_label$marker(): Bool 
}

domain Place  {
  
  unique function _1$place(): Place 
  
  unique function _2$place(): Place 
  
  function deref_reference_place(_0: Place): Place 
  
  unique function _4$place(): Place 
  
  unique function _6$place(): Place 
  
  unique function _5$place(): Place 
  
  unique function _3$place(): Place 
  
  function field_place$$struct$m_LinkedList$$$f$val(_0: Place): Place 
  
  unique function _7$place(): Place 
  
  unique function _0$place(): Place 
  
  unique function _9$place(): Place 
  
  unique function _8$place(): Place 
  
  unique function _14$place(): Place 
  
  unique function _13$place(): Place 
  
  unique function _17$place(): Place 
  
  function field_place$$struct$m_LinkedList$$$f$next(_0: Place): Place 
  
  unique function _18$place(): Place 
  
  function field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(_0: Place): Place 
  
  function variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(_0: Place): Place 
  
  unique function _24$place(): Place 
  
  function field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(_0: Place): Place 
  
  unique function _27$place(): Place 
  
  unique function _26$place(): Place 
  
  unique function _25$place(): Place 
  
  unique function _29$place(): Place 
  
  unique function _30$place(): Place 
  
  unique function _28$place(): Place 
  
  unique function _20$place(): Place 
  
  unique function _19$place(): Place 
  
  function variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(_0: Place): Place 
}

domain Size  {
  
  function Size$Unbounded$(): Snap$Usize 
  
  function Size$Isize$(): Snap$Usize 
  
  function Size$Bool$(): Snap$Usize 
  
  function Size$ref$Shared$Unbounded$(): Snap$Usize 
  
  function Size$I64$(): Snap$Usize 
  
  function Size$Tuple$$$$(): Snap$Usize 
  
  function PaddingSize$Tuple$$$$(): Snap$Usize 
  
  function Size$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function Size$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(): Snap$Usize 
  
  function Size$ref$Shared$struct$m_LinkedList$$(): Snap$Usize 
  
  function Size$Never$(): Snap$Usize 
  
  function PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function PaddingSize$struct$m_LinkedList$$(): Snap$Usize 
}

domain Snap$Bool  {
  
  function constructor$Snap$Bool$(value: Bool): Snap$Bool 
  
  function destructor$Snap$Bool$$value(value: Snap$Bool): Bool 
  
  function valid$Snap$Bool(_0: Snap$Bool): Bool 
  
  function constructor$Snap$Bool$LeCmp_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$LeCmp_Unbounded$left(value: Snap$Bool): Snap$Unbounded 
  
  function destructor$Snap$Bool$LeCmp_Unbounded$right(value: Snap$Bool): Snap$Unbounded 
  
  function constructor$Snap$Bool$GeCmp_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$GeCmp_Unbounded$left(value: Snap$Bool): Snap$Unbounded 
  
  function destructor$Snap$Bool$GeCmp_Unbounded$right(value: Snap$Bool): Snap$Unbounded 
  
  function constructor$Snap$Bool$EqCmp_Isize(left: Snap$Isize, right: Snap$Isize): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_Isize$left(value: Snap$Bool): Snap$Isize 
  
  function destructor$Snap$Bool$EqCmp_Isize$right(value: Snap$Bool): Snap$Isize 
  
  function constructor$Snap$Bool$LtCmp_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$LtCmp_Unbounded$left(value: Snap$Bool): Snap$Unbounded 
  
  function destructor$Snap$Bool$LtCmp_Unbounded$right(value: Snap$Bool): Snap$Unbounded 
  
  function constructor$Snap$Bool$EqCmp_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_Unbounded$left(value: Snap$Bool): Snap$Unbounded 
  
  function destructor$Snap$Bool$EqCmp_Unbounded$right(value: Snap$Bool): Snap$Unbounded 
  
  function constructor$Snap$Bool$EqCmp_ref$Shared$Unbounded(left: Snap$ref$Shared$Unbounded,
  right: Snap$ref$Shared$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_ref$Shared$Unbounded$left(value: Snap$Bool): Snap$ref$Shared$Unbounded 
  
  function destructor$Snap$Bool$EqCmp_ref$Shared$Unbounded$right(value: Snap$Bool): Snap$ref$Shared$Unbounded 
  
  function constructor$Snap$Bool$EqCmp_Bool(left: Snap$Bool, right: Snap$Bool): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_Bool$left(value: Snap$Bool): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_Bool$right(value: Snap$Bool): Snap$Bool 
  
  function to_bytes$Bool(snapshot: Snap$Bool): Bytes 
  
  function constructor$Snap$Bool$GtCmp_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Bool 
  
  function destructor$Snap$Bool$GtCmp_Unbounded$left(value: Snap$Bool): Snap$Unbounded 
  
  function destructor$Snap$Bool$GtCmp_Unbounded$right(value: Snap$Bool): Snap$Unbounded 
  
  function constructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$(left: Snap$ref$Shared$struct$m_LinkedList$,
  right: Snap$ref$Shared$struct$m_LinkedList$): Snap$Bool 
  
  function destructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$$left(value: Snap$Bool): Snap$ref$Shared$struct$m_LinkedList$ 
  
  function destructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$$right(value: Snap$Bool): Snap$ref$Shared$struct$m_LinkedList$ 
  
  axiom constructor$Snap$Bool$$bottom_up_injectivity_axiom {
    (forall value: Bool ::
      { constructor$Snap$Bool$(value) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$(value)) == value)
  }
  
  axiom constructor$Snap$Bool$$top_down_injectivity_axiom {
    (forall value: Snap$Bool ::
      { valid$Snap$Bool(value) }
      valid$Snap$Bool(value) ==>
      value == constructor$Snap$Bool$(destructor$Snap$Bool$$value(value)))
  }
  
  axiom Snap$Bool$$validity_axiom_bottom_up_alternative {
    (forall value: Bool ::
      { valid$Snap$Bool(constructor$Snap$Bool$(value)) }
      valid$Snap$Bool(constructor$Snap$Bool$(value)))
  }
  
  axiom LeCmp_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$LeCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Bool$LeCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Bool$(left <= right))
  }
  
  axiom LeCmp_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$LeCmp_Unbounded(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$LeCmp_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) <=
      destructor$Snap$Unbounded$$value(right))
  }
  
  axiom GeCmp_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$GeCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Bool$GeCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Bool$(left >= right))
  }
  
  axiom GeCmp_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) >=
      destructor$Snap$Unbounded$$value(right))
  }
  
  axiom EqCmp_Isize$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$EqCmp_Isize(constructor$Snap$Isize$(left), constructor$Snap$Isize$(right)) }
      valid$Snap$Isize(constructor$Snap$Isize$(left)) &&
      valid$Snap$Isize(constructor$Snap$Isize$(right)) ==>
      constructor$Snap$Bool$EqCmp_Isize(constructor$Snap$Isize$(left), constructor$Snap$Isize$(right)) ==
      constructor$Snap$Bool$(left == right))
  }
  
  axiom EqCmp_Isize$eval_axiom {
    (forall left: Snap$Isize, right: Snap$Isize ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Isize(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Isize(left, right)) ==
      (destructor$Snap$Isize$$value(left) ==
      destructor$Snap$Isize$$value(right)))
  }
  
  axiom LtCmp_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$LtCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Bool$LtCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Bool$(left < right))
  }
  
  axiom LtCmp_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$LtCmp_Unbounded(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$LtCmp_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) <
      destructor$Snap$Unbounded$$value(right))
  }
  
  axiom EqCmp_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$EqCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Bool$EqCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Bool$(left == right))
  }
  
  axiom EqCmp_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(left,
      right)) ==
      (destructor$Snap$Unbounded$$value(left) ==
      destructor$Snap$Unbounded$$value(right)))
  }
  
  axiom EqCmp_ref$Shared$Unbounded$simplification_axiom {
    (forall left: Snap$ref$Shared$Unbounded, right: Snap$ref$Shared$Unbounded ::
      { constructor$Snap$Bool$EqCmp_ref$Shared$Unbounded(left, right) }
      constructor$Snap$Bool$EqCmp_ref$Shared$Unbounded(left, right) ==
      constructor$Snap$Bool$(left == right))
  }
  
  axiom EqCmp_Bool$simplification_axiom {
    (forall left: Bool, right: Bool ::
      { constructor$Snap$Bool$EqCmp_Bool(constructor$Snap$Bool$(left), constructor$Snap$Bool$(right)) }
      valid$Snap$Bool(constructor$Snap$Bool$(left)) &&
      valid$Snap$Bool(constructor$Snap$Bool$(right)) ==>
      constructor$Snap$Bool$EqCmp_Bool(constructor$Snap$Bool$(left), constructor$Snap$Bool$(right)) ==
      constructor$Snap$Bool$(left == right))
  }
  
  axiom EqCmp_Bool$eval_axiom {
    (forall left: Snap$Bool, right: Snap$Bool ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Bool(left, right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Bool(left, right)) ==
      (destructor$Snap$Bool$$value(left) ==
      destructor$Snap$Bool$$value(right)))
  }
  
  axiom GtCmp_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Bool$GtCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Bool$GtCmp_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Bool$(left > right))
  }
  
  axiom GtCmp_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Bool$$value(constructor$Snap$Bool$GtCmp_Unbounded(left,
      right)) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$GtCmp_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) >
      destructor$Snap$Unbounded$$value(right))
  }
  
  axiom EqCmp_ref$Shared$struct$m_LinkedList$$simplification_axiom {
    (forall left: Snap$ref$Shared$struct$m_LinkedList$, right: Snap$ref$Shared$struct$m_LinkedList$ ::
      { constructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$(left, right) }
      constructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$(left, right) ==
      constructor$Snap$Bool$(left == right))
  }
}

domain Snap$I64  {
  
  function constructor$Snap$I64$(value: Int): Snap$I64 
  
  function destructor$Snap$I64$$value(value: Snap$I64): Int 
  
  function valid$Snap$I64(_0: Snap$I64): Bool 
  
  function to_bytes$I64(snapshot: Snap$I64): Bytes 
  
  axiom constructor$Snap$I64$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$I64$(value) }
      destructor$Snap$I64$$value(constructor$Snap$I64$(value)) == value)
  }
  
  axiom constructor$Snap$I64$$top_down_injectivity_axiom {
    (forall value: Snap$I64 ::
      { valid$Snap$I64(value) }
      valid$Snap$I64(value) ==>
      value == constructor$Snap$I64$(destructor$Snap$I64$$value(value)))
  }
  
  axiom Snap$I64$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$I64(constructor$Snap$I64$(value)) }
      valid$Snap$I64(constructor$Snap$I64$(value)) ==
      (-9223372036854775808 <= value && value <= 9223372036854775807))
  }
}

domain Snap$Isize  {
  
  function constructor$Snap$Isize$(value: Int): Snap$Isize 
  
  function destructor$Snap$Isize$$value(value: Snap$Isize): Int 
  
  function valid$Snap$Isize(_0: Snap$Isize): Bool 
  
  function to_bytes$Isize(snapshot: Snap$Isize): Bytes 
  
  axiom constructor$Snap$Isize$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Isize$(value) }
      destructor$Snap$Isize$$value(constructor$Snap$Isize$(value)) == value)
  }
  
  axiom constructor$Snap$Isize$$top_down_injectivity_axiom {
    (forall value: Snap$Isize ::
      { valid$Snap$Isize(value) }
      valid$Snap$Isize(value) ==>
      value == constructor$Snap$Isize$(destructor$Snap$Isize$$value(value)))
  }
  
  axiom Snap$Isize$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Isize(constructor$Snap$Isize$(value)) }
      valid$Snap$Isize(constructor$Snap$Isize$(value)) ==
      (-9223372036854775808 <= value && value <= 9223372036854775807))
  }
}

domain Snap$Never  {
  
  function constructor$Snap$Never$(): Snap$Never 
  
  function valid$Snap$Never(_0: Snap$Never): Bool 
  
  axiom Snap$Never$validity_axiom_bottom_up_alternative_no_parameters {
    !valid$Snap$Never(constructor$Snap$Never$())
  }
}

domain Snap$Tuple$$$  {
  
  function constructor$Snap$Tuple$$$$(): Snap$Tuple$$$ 
  
  function valid$Snap$Tuple$$$(_0: Snap$Tuple$$$): Bool 
  
  function to_bytes$Tuple$$$(snapshot: Snap$Tuple$$$): Bytes 
  
  axiom Snap$Tuple$$$$validity_axiom_bottom_up_alternative_no_parameters {
    valid$Snap$Tuple$$$(constructor$Snap$Tuple$$$$())
  }
}

domain Snap$Unbounded  {
  
  function constructor$Snap$Unbounded$(value: Int): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$$value(value: Snap$Unbounded): Int 
  
  function valid$Snap$Unbounded(_0: Snap$Unbounded): Bool 
  
  function constructor$Snap$Unbounded$Add_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$Add_Unbounded$left(value: Snap$Unbounded): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$Add_Unbounded$right(value: Snap$Unbounded): Snap$Unbounded 
  
  function constructor$Snap$Unbounded$Sub_Unbounded(left: Snap$Unbounded, right: Snap$Unbounded): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$Sub_Unbounded$left(value: Snap$Unbounded): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$Sub_Unbounded$right(value: Snap$Unbounded): Snap$Unbounded 
  
  function to_bytes$Unbounded(snapshot: Snap$Unbounded): Bytes 
  
  axiom constructor$Snap$Unbounded$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Unbounded$(value) }
      destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$(value)) ==
      value)
  }
  
  axiom constructor$Snap$Unbounded$$top_down_injectivity_axiom {
    (forall value: Snap$Unbounded ::
      { valid$Snap$Unbounded(value) }
      valid$Snap$Unbounded(value) ==>
      value ==
      constructor$Snap$Unbounded$(destructor$Snap$Unbounded$$value(value)))
  }
  
  axiom Snap$Unbounded$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Unbounded(constructor$Snap$Unbounded$(value)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(value)))
  }
  
  axiom Add_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Unbounded$Add_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Unbounded$Add_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Unbounded$(left + right))
  }
  
  axiom Add_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$Add_Unbounded(left,
      right)) }
      destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$Add_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) +
      destructor$Snap$Unbounded$$value(right))
  }
  
  axiom Sub_Unbounded$simplification_axiom {
    (forall left: Int, right: Int ::
      { constructor$Snap$Unbounded$Sub_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(left)) &&
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(right)) ==>
      constructor$Snap$Unbounded$Sub_Unbounded(constructor$Snap$Unbounded$(left),
      constructor$Snap$Unbounded$(right)) ==
      constructor$Snap$Unbounded$(left - right))
  }
  
  axiom Sub_Unbounded$eval_axiom {
    (forall left: Snap$Unbounded, right: Snap$Unbounded ::
      { destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$Sub_Unbounded(left,
      right)) }
      destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$Sub_Unbounded(left,
      right)) ==
      destructor$Snap$Unbounded$$value(left) -
      destructor$Snap$Unbounded$$value(right))
  }
}

domain Snap$Usize  {
  
  function constructor$Snap$Usize$(value: Int): Snap$Usize 
  
  function destructor$Snap$Usize$$value(value: Snap$Usize): Int 
  
  function valid$Snap$Usize(_0: Snap$Usize): Bool 
  
  axiom constructor$Snap$Usize$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Usize$(value) }
      destructor$Snap$Usize$$value(constructor$Snap$Usize$(value)) == value)
  }
  
  axiom constructor$Snap$Usize$$top_down_injectivity_axiom {
    (forall value: Snap$Usize ::
      { valid$Snap$Usize(value) }
      valid$Snap$Usize(value) ==>
      value == constructor$Snap$Usize$(destructor$Snap$Usize$$value(value)))
  }
  
  axiom Snap$Usize$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Usize(constructor$Snap$Usize$(value)) }
      valid$Snap$Usize(constructor$Snap$Usize$(value)) ==
      (0 <= value && value <= 18446744073709551615))
  }
}

domain Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function to_bytes$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_bottom_up_alternative_no_parameters {
    valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$())
  }
}

domain Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$bottom_up_injectivity_axiom {
    (forall f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0) }
      destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)) ==
      f$0)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(value)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_bottom_up_alternative {
    (forall f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)),
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(f$0) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(f$0))
  }
}

domain Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Int 
  
  function to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$bottom_up_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value) }
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value)) ==
      value)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==
      0 ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(value)))
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$bottom_up_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value) }
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value)) ==
      value)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==
      1 ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(value)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_top_down_enum {
    (forall snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot) }
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot) }
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      (0 <=
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) <=
      1 &&
      ((discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      0 ==>
      valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot))) &&
      (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      1 ==>
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot))))))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$validity_axiom_bottom_up_enum_variant {
    (forall variant: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant),
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) ==
      valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$discriminant_axiom {
    (forall variant: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant) }
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) ==
      0)
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$validity_axiom_bottom_up_enum_variant {
    (forall variant: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant),
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) ==
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$discriminant_axiom {
    (forall variant: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant) }
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) ==
      1)
  }
}

domain Snap$ptr$Unbounded  {
  
  function to_bytes$ptr$Unbounded(snapshot: Snap$ptr$Unbounded): Bytes 
  
  function constructor$Snap$ptr$Unbounded$(value: Address): Snap$ptr$Unbounded 
  
  function destructor$Snap$ptr$Unbounded$$value(value: Snap$ptr$Unbounded): Address 
  
  function valid$Snap$ptr$Unbounded(_0: Snap$ptr$Unbounded): Bool 
  
  axiom constructor$Snap$ptr$Unbounded$$bottom_up_injectivity_axiom {
    (forall value: Address ::
      { constructor$Snap$ptr$Unbounded$(value) }
      destructor$Snap$ptr$Unbounded$$value(constructor$Snap$ptr$Unbounded$(value)) ==
      value)
  }
  
  axiom constructor$Snap$ptr$Unbounded$$top_down_injectivity_axiom {
    (forall value: Snap$ptr$Unbounded ::
      { valid$Snap$ptr$Unbounded(value) }
      valid$Snap$ptr$Unbounded(value) ==>
      value ==
      constructor$Snap$ptr$Unbounded$(destructor$Snap$ptr$Unbounded$$value(value)))
  }
  
  axiom Snap$ptr$Unbounded$$validity_axiom_bottom_up_alternative {
    (forall value: Address ::
      { valid$Snap$ptr$Unbounded(constructor$Snap$ptr$Unbounded$(value)) }
      valid$Snap$ptr$Unbounded(constructor$Snap$ptr$Unbounded$(value)))
  }
}

domain Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function to_bytes$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  function constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(value: Address): Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$value(value: Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Address 
  
  function valid$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  axiom constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$bottom_up_injectivity_axiom {
    (forall value: Address ::
      { constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(value) }
      destructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$value(constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(value)) ==
      value)
  }
  
  axiom constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$top_down_injectivity_axiom {
    (forall value: Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==>
      value ==
      constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(destructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$value(value)))
  }
  
  axiom Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_bottom_up_alternative {
    (forall value: Address ::
      { valid$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(value)) }
      valid$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ptr$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(value)))
  }
}

domain Snap$ptr$struct$m_LinkedList$  {
  
  function to_bytes$ptr$struct$m_LinkedList$(snapshot: Snap$ptr$struct$m_LinkedList$): Bytes 
  
  function constructor$Snap$ptr$struct$m_LinkedList$$(value: Address): Snap$ptr$struct$m_LinkedList$ 
  
  function destructor$Snap$ptr$struct$m_LinkedList$$$value(value: Snap$ptr$struct$m_LinkedList$): Address 
  
  function valid$Snap$ptr$struct$m_LinkedList$(_0: Snap$ptr$struct$m_LinkedList$): Bool 
  
  axiom constructor$Snap$ptr$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall value: Address ::
      { constructor$Snap$ptr$struct$m_LinkedList$$(value) }
      destructor$Snap$ptr$struct$m_LinkedList$$$value(constructor$Snap$ptr$struct$m_LinkedList$$(value)) ==
      value)
  }
  
  axiom constructor$Snap$ptr$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$ptr$struct$m_LinkedList$ ::
      { valid$Snap$ptr$struct$m_LinkedList$(value) }
      valid$Snap$ptr$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ptr$struct$m_LinkedList$$(destructor$Snap$ptr$struct$m_LinkedList$$$value(value)))
  }
  
  axiom Snap$ptr$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall value: Address ::
      { valid$Snap$ptr$struct$m_LinkedList$(constructor$Snap$ptr$struct$m_LinkedList$$(value)) }
      valid$Snap$ptr$struct$m_LinkedList$(constructor$Snap$ptr$struct$m_LinkedList$$(value)))
  }
}

domain Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$  {
  
  function to_bytes$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot: Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bytes 
  
  function constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value: Address): Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function destructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$value(value: Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$): Address 
  
  function valid$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(_0: Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bool 
  
  axiom constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$bottom_up_injectivity_axiom {
    (forall value: Address ::
      { constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      destructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$value(constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value)) ==
      value)
  }
  
  axiom constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$top_down_injectivity_axiom {
    (forall value: Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(value) }
      valid$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(value) ==>
      value ==
      constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$value(value)))
  }
  
  axiom Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_bottom_up_alternative {
    (forall value: Address ::
      { valid$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value)) }
      valid$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ptr$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value)))
  }
}

domain Snap$ref$Shared$Unbounded  {
  
  function constructor$Snap$ref$Shared$Unbounded$(address: Address, target_current: Snap$Unbounded): Snap$ref$Shared$Unbounded 
  
  function destructor$Snap$ref$Shared$Unbounded$$address(value: Snap$ref$Shared$Unbounded): Address 
  
  function destructor$Snap$ref$Shared$Unbounded$$target_current(value: Snap$ref$Shared$Unbounded): Snap$Unbounded 
  
  function valid$Snap$ref$Shared$Unbounded(_0: Snap$ref$Shared$Unbounded): Bool 
  
  function constructor$Snap$ref$Shared$Unbounded$no_alloc(target_current: Snap$Unbounded): Snap$ref$Shared$Unbounded 
  
  function to_bytes$ref$Shared$Unbounded(snapshot: Snap$ref$Shared$Unbounded): Bytes 
  
  axiom constructor$Snap$ref$Shared$Unbounded$$bottom_up_injectivity_axiom {
    (forall address: Address, target_current: Snap$Unbounded ::
      { constructor$Snap$ref$Shared$Unbounded$(address, target_current) }
      { constructor$Snap$ref$Shared$Unbounded$(address, target_current) }
      destructor$Snap$ref$Shared$Unbounded$$address(constructor$Snap$ref$Shared$Unbounded$(address,
      target_current)) ==
      address &&
      destructor$Snap$ref$Shared$Unbounded$$target_current(constructor$Snap$ref$Shared$Unbounded$(address,
      target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$Unbounded$$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(value), destructor$Snap$ref$Shared$Unbounded$$address(value) }
      { valid$Snap$ref$Shared$Unbounded(value), destructor$Snap$ref$Shared$Unbounded$$target_current(value) }
      valid$Snap$ref$Shared$Unbounded(value) ==>
      value ==
      constructor$Snap$ref$Shared$Unbounded$(destructor$Snap$ref$Shared$Unbounded$$address(value),
      destructor$Snap$ref$Shared$Unbounded$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$Unbounded$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(snapshot), destructor$Snap$ref$Shared$Unbounded$$target_current(snapshot) }
      valid$Snap$ref$Shared$Unbounded(snapshot) ==
      valid$Snap$Unbounded(destructor$Snap$ref$Shared$Unbounded$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$Unbounded$$validity_axiom_bottom_up_alternative {
    (forall address: Address, target_current: Snap$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(constructor$Snap$ref$Shared$Unbounded$(address,
      target_current)), valid$Snap$Unbounded(target_current) }
      valid$Snap$ref$Shared$Unbounded(constructor$Snap$ref$Shared$Unbounded$(address,
      target_current)) ==
      valid$Snap$Unbounded(target_current))
  }
  
  axiom constructor$Snap$ref$Shared$Unbounded$no_alloc$bottom_up_injectivity_axiom {
    (forall target_current: Snap$Unbounded ::
      { constructor$Snap$ref$Shared$Unbounded$no_alloc(target_current) }
      destructor$Snap$ref$Shared$Unbounded$$target_current(constructor$Snap$ref$Shared$Unbounded$no_alloc(target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$Unbounded$no_alloc$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(value) }
      valid$Snap$ref$Shared$Unbounded(value) ==>
      value ==
      constructor$Snap$ref$Shared$Unbounded$no_alloc(destructor$Snap$ref$Shared$Unbounded$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$Unbounded$no_alloc$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(snapshot), destructor$Snap$ref$Shared$Unbounded$$target_current(snapshot) }
      valid$Snap$ref$Shared$Unbounded(snapshot) ==
      valid$Snap$Unbounded(destructor$Snap$ref$Shared$Unbounded$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$Unbounded$no_alloc$validity_axiom_bottom_up_alternative {
    (forall target_current: Snap$Unbounded ::
      { valid$Snap$ref$Shared$Unbounded(constructor$Snap$ref$Shared$Unbounded$no_alloc(target_current)),
      valid$Snap$Unbounded(target_current) }
      valid$Snap$ref$Shared$Unbounded(constructor$Snap$ref$Shared$Unbounded$no_alloc(target_current)) ==
      valid$Snap$Unbounded(target_current))
  }
}

domain Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address: Address,
  target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(value: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Address 
  
  function destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(value: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function to_bytes$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$bottom_up_injectivity_axiom {
    (forall address: Address, target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current) }
      { constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current) }
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current)) ==
      address &&
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value),
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(value) }
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value),
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(value) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==>
      value ==
      constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(value),
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(snapshot) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_bottom_up_alternative {
    (forall address: Address, target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current)), valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_current) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(address,
      target_current)) ==
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_current))
  }
  
  axiom constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc$bottom_up_injectivity_axiom {
    (forall target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(target_current) }
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==>
      value ==
      constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(snapshot) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc$validity_axiom_bottom_up_alternative {
    (forall target_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(target_current)),
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_current) }
      valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$no_alloc(target_current)) ==
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_current))
  }
}

domain Snap$ref$Shared$struct$m_LinkedList$  {
  
  function constructor$Snap$ref$Shared$struct$m_LinkedList$$(address: Address,
  target_current: Snap$struct$m_LinkedList$): Snap$ref$Shared$struct$m_LinkedList$ 
  
  function destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value: Snap$ref$Shared$struct$m_LinkedList$): Address 
  
  function destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value: Snap$ref$Shared$struct$m_LinkedList$): Snap$struct$m_LinkedList$ 
  
  function valid$Snap$ref$Shared$struct$m_LinkedList$(_0: Snap$ref$Shared$struct$m_LinkedList$): Bool 
  
  function constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current: Snap$struct$m_LinkedList$): Snap$ref$Shared$struct$m_LinkedList$ 
  
  function to_bytes$ref$Shared$struct$m_LinkedList$(snapshot: Snap$ref$Shared$struct$m_LinkedList$): Bytes 
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall address: Address, target_current: Snap$struct$m_LinkedList$ ::
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$(address, target_current) }
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$(address, target_current) }
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      address &&
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value) }
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ref$Shared$struct$m_LinkedList$$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value),
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot) ==
      valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall address: Address, target_current: Snap$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)), valid$Snap$struct$m_LinkedList$(target_current) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      valid$Snap$struct$m_LinkedList$(target_current))
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc$bottom_up_injectivity_axiom {
    (forall target_current: Snap$struct$m_LinkedList$ ::
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current) }
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$no_alloc$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot) ==
      valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$no_alloc$validity_axiom_bottom_up_alternative {
    (forall target_current: Snap$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)),
      valid$Snap$struct$m_LinkedList$(target_current) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)) ==
      valid$Snap$struct$m_LinkedList$(target_current))
  }
}

domain Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$  {
  
  function constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$): Address 
  
  function destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(_0: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bool 
  
  function constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function to_bytes$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bytes 
  
  axiom constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$bottom_up_injectivity_axiom {
    (forall address: Address, target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current) }
      { constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current) }
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current)) ==
      address &&
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(value),
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(value) }
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(value),
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(value) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(value) ==>
      value ==
      constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(value),
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot),
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(snapshot) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_bottom_up_alternative {
    (forall address: Address, target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current)), valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_current) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address,
      target_current)) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_current))
  }
  
  axiom constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc$bottom_up_injectivity_axiom {
    (forall target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(target_current) }
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(value) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(value) ==>
      value ==
      constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot),
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(snapshot) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc$validity_axiom_bottom_up_alternative {
    (forall target_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(target_current)),
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_current) }
      valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(constructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$no_alloc(target_current)) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_current))
  }
}

domain Snap$struct$m_LinkedList$  {
  
  function constructor$Snap$struct$m_LinkedList$$(f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$struct$m_LinkedList$ 
  
  function destructor$Snap$struct$m_LinkedList$$$f$val(value: Snap$struct$m_LinkedList$): Snap$I64 
  
  function destructor$Snap$struct$m_LinkedList$$$f$next(value: Snap$struct$m_LinkedList$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$struct$m_LinkedList$(_0: Snap$struct$m_LinkedList$): Bool 
  
  function to_bytes$struct$m_LinkedList$(snapshot: Snap$struct$m_LinkedList$): Bytes 
  
  axiom constructor$Snap$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$struct$m_LinkedList$$(f$val, f$next) }
      { constructor$Snap$struct$m_LinkedList$$(f$val, f$next) }
      destructor$Snap$struct$m_LinkedList$$$f$val(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      f$val &&
      destructor$Snap$struct$m_LinkedList$$$f$next(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      f$next)
  }
  
  axiom constructor$Snap$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$struct$m_LinkedList$ ::
      { valid$Snap$struct$m_LinkedList$(value), destructor$Snap$struct$m_LinkedList$$$f$val(value) }
      { valid$Snap$struct$m_LinkedList$(value), destructor$Snap$struct$m_LinkedList$$$f$next(value) }
      valid$Snap$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$struct$m_LinkedList$$(destructor$Snap$struct$m_LinkedList$$$f$val(value),
      destructor$Snap$struct$m_LinkedList$$$f$next(value)))
  }
  
  axiom Snap$struct$m_LinkedList$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$struct$m_LinkedList$ ::
      { valid$Snap$struct$m_LinkedList$(snapshot), destructor$Snap$struct$m_LinkedList$$$f$val(snapshot) }
      { valid$Snap$struct$m_LinkedList$(snapshot), destructor$Snap$struct$m_LinkedList$$$f$next(snapshot) }
      valid$Snap$struct$m_LinkedList$(snapshot) ==
      (valid$Snap$I64(destructor$Snap$struct$m_LinkedList$$$f$val(snapshot)) &&
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$struct$m_LinkedList$$$f$next(snapshot))))
  }
  
  axiom Snap$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$struct$m_LinkedList$(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)), valid$Snap$I64(f$val), valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(f$next) }
      valid$Snap$struct$m_LinkedList$(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      (valid$Snap$I64(f$val) &&
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(f$next)))
  }
}

domain Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$  {
  
  function valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(_0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bool 
  
  function to_bytes$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bytes 
}

domain ComputeAddress  {
  
  function compute_address(place: Place, address: Address): Address 
  
  axiom root$1$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_1$place(), address) }
      compute_address(_1$place(), address) == address)
  }
  
  axiom root$2$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_2$place(), address) }
      compute_address(_2$place(), address) == address)
  }
  
  axiom ref$Shared$Unbounded$compute_address_axiom {
    (forall place: Place, snapshot: Snap$ref$Shared$Unbounded ::
      { compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$Unbounded$$address(snapshot)) }
      compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$Unbounded$$address(snapshot)) ==
      destructor$Snap$ref$Shared$Unbounded$$address(snapshot))
  }
  
  axiom root$3$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_4$place(), address) }
      compute_address(_4$place(), address) == address)
  }
  
  axiom root$4$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_6$place(), address) }
      compute_address(_6$place(), address) == address)
  }
  
  axiom root$5$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_5$place(), address) }
      compute_address(_5$place(), address) == address)
  }
  
  axiom root$6$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_3$place(), address) }
      compute_address(_3$place(), address) == address)
  }
  
  axiom root$7$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_7$place(), address) }
      compute_address(_7$place(), address) == address)
  }
  
  axiom root$8$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_0$place(), address) }
      compute_address(_0$place(), address) == address)
  }
  
  axiom root$9$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_9$place(), address) }
      compute_address(_9$place(), address) == address)
  }
  
  axiom root$10$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_8$place(), address) }
      compute_address(_8$place(), address) == address)
  }
  
  axiom root$11$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_14$place(), address) }
      compute_address(_14$place(), address) == address)
  }
  
  axiom root$12$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_13$place(), address) }
      compute_address(_13$place(), address) == address)
  }
  
  axiom ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$compute_address_axiom {
    (forall place: Place, snapshot: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(snapshot)) }
      compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(snapshot)) ==
      destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(snapshot))
  }
  
  axiom root$13$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_17$place(), address) }
      compute_address(_17$place(), address) == address)
  }
  
  axiom root$14$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_18$place(), address) }
      compute_address(_18$place(), address) == address)
  }
  
  axiom ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$compute_address_axiom {
    (forall place: Place, snapshot: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(snapshot)) }
      compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(snapshot)) ==
      destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(snapshot))
  }
  
  axiom root$15$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_24$place(), address) }
      compute_address(_24$place(), address) == address)
  }
  
  axiom root$16$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_27$place(), address) }
      compute_address(_27$place(), address) == address)
  }
  
  axiom root$17$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_26$place(), address) }
      compute_address(_26$place(), address) == address)
  }
  
  axiom ref$Shared$struct$m_LinkedList$$compute_address_axiom {
    (forall place: Place, snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot)) }
      compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot)) ==
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot))
  }
  
  axiom root$18$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_25$place(), address) }
      compute_address(_25$place(), address) == address)
  }
  
  axiom root$19$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_29$place(), address) }
      compute_address(_29$place(), address) == address)
  }
  
  axiom root$20$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_30$place(), address) }
      compute_address(_30$place(), address) == address)
  }
  
  axiom root$21$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_28$place(), address) }
      compute_address(_28$place(), address) == address)
  }
  
  axiom root$22$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_20$place(), address) }
      compute_address(_20$place(), address) == address)
  }
  
  axiom root$23$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_19$place(), address) }
      compute_address(_19$place(), address) == address)
  }
  
  axiom struct$m_LinkedList$$f$val$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$struct$m_LinkedList$$$f$val(place), address) }
      compute_address(field_place$$struct$m_LinkedList$$$f$val(place), address) ==
      field_address$$struct$m_LinkedList$$$f$val(compute_address(place, address)))
  }
  
  axiom struct$m_LinkedList$$f$next$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$struct$m_LinkedList$$$f$next(place), address) }
      compute_address(field_place$$struct$m_LinkedList$$$f$next(place), address) ==
      field_address$$struct$m_LinkedList$$$f$next(compute_address(place, address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$discriminant$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
      address) }
      compute_address(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
      address) ==
      field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
      address) }
      compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
      address) ==
      variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
      address) }
      compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
      address) ==
      variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$f$0$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
      address) }
      compute_address(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
      address) ==
      field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(compute_address(place,
      address)))
  }
}

function caller_for$m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$ref$Shared$struct$m_LinkedList$
  requires true
  requires valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(_1)
  ensures true
  ensures valid$Snap$ref$Shared$struct$m_LinkedList$(result)
{
  m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_1, function_gas_level$(function_gas_level$(function_no_gas$())))
}

function caller_for$m_LinkedList$$len$(_1: Snap$ref$Shared$struct$m_LinkedList$): Snap$Unbounded
  requires true
  requires valid$Snap$ref$Shared$struct$m_LinkedList$(_1)
  ensures destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(result,
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1)))))
  ensures valid$Snap$Unbounded(result)
{
  m_LinkedList$$len$(_1, function_gas_level$(function_gas_level$(function_no_gas$())))
}

method m_LinkedList$$lookup$Specifications()
{
  var _0$address: Address
  var _0$snapshot$0: Snap$Unbounded
  var _1$address: Address
  var _1$snapshot$0: Snap$ref$Shared$struct$m_LinkedList$
  var _13$address: Address
  var _13$snapshot$0: Snap$Tuple$$$
  var _13$snapshot$1: Snap$Tuple$$$
  var _13$snapshot$2: Snap$Tuple$$$
  var _13$snapshot$3: Snap$Tuple$$$
  var _14$address: Address
  var _14$snapshot$0: Snap$Bool
  var _14$snapshot$1: Snap$Bool
  var _14$snapshot$2: Snap$Bool
  var _14$snapshot$3: Snap$Bool
  var _17$address: Address
  var _17$snapshot$0: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _17$snapshot$1: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _17$snapshot$2: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _17$snapshot$3: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _18$address: Address
  var _18$snapshot$0: Snap$Isize
  var _18$snapshot$1: Snap$Isize
  var _18$snapshot$2: Snap$Isize
  var _18$snapshot$3: Snap$Isize
  var _19$address: Address
  var _19$snapshot$0: Snap$Tuple$$$
  var _19$snapshot$1: Snap$Tuple$$$
  var _19$snapshot$2: Snap$Tuple$$$
  var _19$snapshot$3: Snap$Tuple$$$
  var _19$snapshot$4: Snap$Tuple$$$
  var _2$address: Address
  var _2$snapshot$0: Snap$Unbounded
  var _2$snapshot$1: Snap$Unbounded
  var _20$address: Address
  var _20$snapshot$0: Snap$Bool
  var _20$snapshot$1: Snap$Bool
  var _20$snapshot$2: Snap$Bool
  var _20$snapshot$3: Snap$Bool
  var _20$snapshot$4: Snap$Bool
  var _23$address: Address
  var _24$address: Address
  var _24$snapshot$0: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _24$snapshot$1: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _24$snapshot$2: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _24$snapshot$3: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _24$snapshot$4: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _24$snapshot$5: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _25$address: Address
  var _25$snapshot$0: Snap$ref$Shared$struct$m_LinkedList$
  var _25$snapshot$1: Snap$ref$Shared$struct$m_LinkedList$
  var _25$snapshot$2: Snap$ref$Shared$struct$m_LinkedList$
  var _25$snapshot$3: Snap$ref$Shared$struct$m_LinkedList$
  var _25$snapshot$4: Snap$ref$Shared$struct$m_LinkedList$
  var _25$snapshot$5: Snap$ref$Shared$struct$m_LinkedList$
  var _26$address: Address
  var _26$snapshot$0: Snap$ref$Shared$struct$m_LinkedList$
  var _27$address: Address
  var _27$snapshot$0: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _27$snapshot$1: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _27$snapshot$2: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _27$snapshot$3: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _27$snapshot$4: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _27$snapshot$5: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _28$address: Address
  var _28$snapshot$0: Snap$Unbounded
  var _29$address: Address
  var _29$snapshot$0: Snap$Unbounded
  var _29$snapshot$1: Snap$Unbounded
  var _29$snapshot$2: Snap$Unbounded
  var _29$snapshot$3: Snap$Unbounded
  var _29$snapshot$4: Snap$Unbounded
  var _29$snapshot$5: Snap$Unbounded
  var _3$address: Address
  var _3$snapshot$0: Snap$Bool
  var _30$address: Address
  var _30$snapshot$0: Snap$Unbounded
  var _4$address: Address
  var _4$snapshot$0: Snap$ref$Shared$Unbounded
  var _4$snapshot$1: Snap$ref$Shared$Unbounded
  var _5$address: Address
  var _5$snapshot$0: Snap$ref$Shared$Unbounded
  var _5$snapshot$1: Snap$ref$Shared$Unbounded
  var _6$address: Address
  var _6$snapshot$0: Snap$Unbounded
  var _6$snapshot$1: Snap$Unbounded
  var _7$address: Address
  var _7$snapshot$0: Snap$I64
  var _7$snapshot$1: Snap$I64
  var _7$snapshot$2: Snap$I64
  var _7$snapshot$3: Snap$I64
  var _8$address: Address
  var _8$snapshot$0: Snap$Tuple$$$
  var _8$snapshot$1: Snap$Tuple$$$
  var _8$snapshot$2: Snap$Tuple$$$
  var _8$snapshot$3: Snap$Tuple$$$
  var _9$address: Address
  var _9$snapshot$0: Snap$Bool
  var _9$snapshot$1: Snap$Bool
  var _9$snapshot$2: Snap$Bool
  var _9$snapshot$3: Snap$Bool
  var bw0$snapshot$0: Lifetime
  var bw1$snapshot$0: Lifetime
  var bw6$snapshot$0: Lifetime
  var bw7$snapshot$0: Lifetime
  var bw8$snapshot$0: Lifetime
  var end_label$marker: Bool
  var label_10_custom$marker: Bool
  var label_12_custom$marker: Bool
  var label_13_custom$marker: Bool
  var label_2_custom$marker: Bool
  var label_3_custom$marker: Bool
  var label_5_custom$marker: Bool
  var label_6_custom$marker: Bool
  var label_7_custom$marker: Bool
  var label_9_custom$marker: Bool
  var label_bb0$marker: Bool
  var label_bb1$marker: Bool
  var label_bb10$marker: Bool
  var label_bb11$marker: Bool
  var label_bb12$marker: Bool
  var label_bb13$marker: Bool
  var label_bb14$marker: Bool
  var label_bb15$marker: Bool
  var label_bb17$marker: Bool
  var label_bb18$marker: Bool
  var label_bb19$marker: Bool
  var label_bb2$marker: Bool
  var label_bb20$marker: Bool
  var label_bb21$marker: Bool
  var label_bb22$marker: Bool
  var label_bb23$marker: Bool
  var label_bb24$marker: Bool
  var label_bb3$marker: Bool
  var label_bb4$marker: Bool
  var label_bb5$marker: Bool
  var label_bb7$marker: Bool
  var label_bb8$marker: Bool
  var label_entry$marker: Bool
  var lft_0$snapshot$1: Lifetime
  var lft_1$snapshot$1: Lifetime
  var lft_13$snapshot$0: Lifetime
  var lft_13$snapshot$1: Lifetime
  var lft_13$snapshot$2: Lifetime
  var lft_13$snapshot$3: Lifetime
  var lft_14$snapshot$0: Lifetime
  var lft_14$snapshot$1: Lifetime
  var lft_14$snapshot$2: Lifetime
  var lft_14$snapshot$3: Lifetime
  var lft_14$snapshot$4: Lifetime
  var lft_14$snapshot$5: Lifetime
  var lft_15$snapshot$0: Lifetime
  var lft_15$snapshot$1: Lifetime
  var lft_15$snapshot$2: Lifetime
  var lft_15$snapshot$3: Lifetime
  var lft_15$snapshot$4: Lifetime
  var lft_15$snapshot$5: Lifetime
  var lft_2$snapshot$1: Lifetime
  var lft_20$snapshot$0: Lifetime
  var lft_20$snapshot$1: Lifetime
  var lft_20$snapshot$2: Lifetime
  var lft_20$snapshot$3: Lifetime
  var lft_20$snapshot$4: Lifetime
  var lft_20$snapshot$5: Lifetime
  var lft_21$alive$snapshot$0: Bool
  var lft_21$snapshot$1: Lifetime
  var lft_22$alive$snapshot$0: Bool
  var lft_22$snapshot$1: Lifetime
  var lft_23$alive$snapshot$0: Bool
  var lft_23$snapshot$1: Lifetime
  var lft_3$snapshot$1: Lifetime
  var lft_34$alive$snapshot$0: Bool
  var lft_34$snapshot$0: Lifetime
  var lft_34$snapshot$1: Lifetime
  var lft_34$snapshot$2: Lifetime
  var lft_34$snapshot$3: Lifetime
  var lft_39$alive$snapshot$0: Bool
  var lft_39$snapshot$0: Lifetime
  var lft_39$snapshot$1: Lifetime
  var lft_39$snapshot$2: Lifetime
  var lft_39$snapshot$3: Lifetime
  var lft_39$snapshot$4: Lifetime
  var lft_39$snapshot$5: Lifetime
  var lft_4$snapshot$1: Lifetime
  var lft_40$alive$snapshot$0: Bool
  var lft_40$snapshot$0: Lifetime
  var lft_40$snapshot$1: Lifetime
  var lft_40$snapshot$2: Lifetime
  var lft_40$snapshot$3: Lifetime
  var lft_40$snapshot$4: Lifetime
  var lft_40$snapshot$5: Lifetime
  var lft_41$alive$snapshot$0: Bool
  var lft_41$snapshot$0: Lifetime
  var lft_41$snapshot$1: Lifetime
  var lft_41$snapshot$2: Lifetime
  var lft_41$snapshot$3: Lifetime
  var lft_41$snapshot$4: Lifetime
  var lft_41$snapshot$5: Lifetime
  var lft_42$alive$snapshot$0: Bool
  var lft_42$snapshot$0: Lifetime
  var lft_42$snapshot$1: Lifetime
  var lft_42$snapshot$2: Lifetime
  var lft_42$snapshot$3: Lifetime
  var lft_42$snapshot$4: Lifetime
  var lft_42$snapshot$5: Lifetime
  var lft_43$snapshot$1: Lifetime
  var lft_44$snapshot$1: Lifetime
  var lft_45$snapshot$0: Lifetime
  var lft_45$snapshot$1: Lifetime
  var lft_45$snapshot$2: Lifetime
  var lft_45$snapshot$3: Lifetime
  var lft_45$snapshot$4: Lifetime
  var lft_45$snapshot$5: Lifetime
  var lft_46$snapshot$0: Lifetime
  var lft_46$snapshot$1: Lifetime
  var lft_46$snapshot$2: Lifetime
  var lft_46$snapshot$3: Lifetime
  var lft_46$snapshot$4: Lifetime
  var lft_46$snapshot$5: Lifetime
  var lft_function_call_1$snapshot$0: Lifetime
  var lft_function_call_1$snapshot$1: Lifetime
  var lft_function_call_1$snapshot$2: Lifetime
  var lft_function_call_1$snapshot$3: Lifetime
  var lft_function_call_1$snapshot$4: Lifetime
  var lft_function_call_1$snapshot$5: Lifetime
  var lft_function_call_2$snapshot$0: Lifetime
  var lft_function_call_2$snapshot$1: Lifetime
  var lft_function_call_2$snapshot$2: Lifetime
  var lft_function_call_2$snapshot$3: Lifetime
  var lft_function_call_2$snapshot$4: Lifetime
  var lft_function_call_2$snapshot$5: Lifetime
  var lifetime_token_perm_amount$0$snapshot$0: Perm
  var old_lft_22_0$snapshot$1: Lifetime
  var old_lft_34_1$snapshot$0: Lifetime
  var old_lft_34_1$snapshot$1: Lifetime
  var old_lft_34_1$snapshot$2: Lifetime
  var old_lft_34_1$snapshot$3: Lifetime
  var old_lft_34_1$snapshot$4: Lifetime
  var old_lft_34_2$snapshot$0: Lifetime
  var old_lft_34_2$snapshot$1: Lifetime
  var old_lft_34_2$snapshot$2: Lifetime
  var old_lft_34_2$snapshot$3: Lifetime
  var old_lft_34_2$snapshot$4: Lifetime
  var old_lft_34_2$snapshot$5: Lifetime
  var old_lft_40_4$snapshot$0: Lifetime
  var old_lft_40_4$snapshot$1: Lifetime
  var old_lft_40_4$snapshot$2: Lifetime
  var old_lft_40_4$snapshot$3: Lifetime
  var old_lft_40_4$snapshot$4: Lifetime
  var old_lft_40_4$snapshot$5: Lifetime
  var old_lft_40_5$snapshot$0: Lifetime
  var old_lft_40_5$snapshot$1: Lifetime
  var old_lft_40_5$snapshot$2: Lifetime
  var old_lft_40_5$snapshot$3: Lifetime
  var old_lft_40_5$snapshot$4: Lifetime
  var old_lft_40_5$snapshot$5: Lifetime
  var old_lft_41_3$snapshot$0: Lifetime
  var old_lft_41_3$snapshot$1: Lifetime
  var old_lft_41_3$snapshot$2: Lifetime
  var old_lft_41_3$snapshot$3: Lifetime
  var old_lft_41_3$snapshot$4: Lifetime
  var old_lft_41_3$snapshot$5: Lifetime
  var resume_panic_label$marker: Bool
  var return_label$marker: Bool
  var start_label$marker: Bool
  var termination_var$1$snapshot$0: Snap$Unbounded
  var termination_var$1$snapshot$1: Snap$Unbounded
  var tmp$0: Snap$ref$Shared$Unbounded
  var tmp$1: Snap$ref$Shared$Unbounded
  var tmp$2: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var tmp$3: Snap$Isize
  var tmp$4: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var tmp$5: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var tmp$6: Bool
  var tmp$7: Snap$ref$Shared$struct$m_LinkedList$
  var tmp$8: Bool
  var tmp_frac_ref_perm$14$snapshot$0: Perm
  var tmp_frac_ref_perm$4$snapshot$0: Perm
  label start_label
  lft_21$alive$snapshot$0 := true
  lft_22$alive$snapshot$0 := true
  lft_23$alive$snapshot$0 := true
  lft_34$alive$snapshot$0 := true
  lft_39$alive$snapshot$0 := true
  lft_40$alive$snapshot$0 := true
  lft_41$alive$snapshot$0 := true
  lft_42$alive$snapshot$0 := true
  start_label$marker := false
  label_entry$marker := false
  label_bb0$marker := false
  label_bb1$marker := false
  label_bb2$marker := false
  label_3_custom$marker := false
  label_bb3$marker := false
  label_bb4$marker := false
  label_2_custom$marker := false
  label_bb5$marker := false
  label_bb7$marker := false
  label_bb8$marker := false
  label_bb10$marker := false
  label_bb11$marker := false
  label_7_custom$marker := false
  label_bb14$marker := false
  label_6_custom$marker := false
  label_bb13$marker := false
  label_9_custom$marker := false
  label_bb19$marker := false
  label_bb20$marker := false
  label_bb21$marker := false
  label_5_custom$marker := false
  label_bb12$marker := false
  label_bb15$marker := false
  label_bb17$marker := false
  label_bb18$marker := false
  label_13_custom$marker := false
  label_12_custom$marker := false
  label_bb22$marker := false
  label_bb23$marker := false
  return_label$marker := false
  label_10_custom$marker := false
  label_bb24$marker := false
  resume_panic_label$marker := false
  end_label$marker := false
  start_label$marker := true
  inhale basic_block_marker$start_label$marker()
  // Lifetime preconditions.
  inhale lifetime_token_perm_amount$0$snapshot$0 > none
  inhale lifetime_token_perm_amount$0$snapshot$0 < write
  inhale true
  inhale true
  inhale true
  lft_0$snapshot$1 := bw6$snapshot$0
  lft_1$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_2$snapshot$1 := lft_tok_sep_take$3(bw6$snapshot$0, bw7$snapshot$0, bw8$snapshot$0,
    lifetime_token_perm_amount$0$snapshot$0 / 59)
  lft_21$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // Allocate the parameters.
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_1$snapshot$0)
  inhale valid$Snap$Unbounded(_2$snapshot$0)
  // Assume functional preconditions.
  inhale !!destructor$Snap$Bool$$value(constructor$Snap$Bool$LeCmp_Unbounded(constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(0))),
    _2$snapshot$0)) &&
    destructor$Snap$Bool$$value(constructor$Snap$Bool$LtCmp_Unbounded(_2$snapshot$0,
    caller_for$m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0)))))
  inhale termination_var$1$snapshot$1 == _2$snapshot$0
  // Allocate the return place.
  inhale true
  // Allocate implicitly allocated statements.
  inhale true
  goto label_entry
  label label_entry
  label_entry$marker := true
  inhale basic_block_marker$label_entry$marker()
  goto label_bb0
  label label_bb0
  label_bb0$marker := true
  inhale basic_block_marker$label_bb0$marker()
  // Prepare lifetimes for statement mid bb0[0]
  // bb0[0] StorageLive(_3)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb0[1]
  // Prepare lifetimes for statement mid bb0[1]
  // bb0[1] StorageLive(_4)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb0[2]
  // Prepare lifetimes for statement mid bb0[2]
  bw0$snapshot$0 := newlft()
  lft_22$snapshot$1 := bw0$snapshot$0
  lft_3$snapshot$1 := bw0$snapshot$0
  // bb0[2] _4 = &_2
  tmp$0 := assign$ref$Shared$Unbounded$Ref$Unbounded$$lft_3$$(_4$place(), _4$address,
    _2$place(), _2$address, _2$snapshot$0, lft_3$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _4$snapshot$1 == tmp$0
  inhale _2$snapshot$1 ==
    destructor$Snap$ref$Shared$Unbounded$$target_current(tmp$0)
  // Prepare lifetimes for statement start bb0[3]
  // Prepare lifetimes for statement mid bb0[3]
  // bb0[3] StorageLive(_5)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb0[4]
  // Prepare lifetimes for statement mid bb0[4]
  // bb0[4] StorageLive(_6)
  inhale true
  inhale true
  // Prepare lifetimes for statement mid bb0[5]
  // bb0[5] _6 = prusti_contracts::Int::new(const 0_i64) -> [return: bb1, unwind: bb24]
  consume$Constant$I64(constructor$Snap$I64$(0))
  exhale true
  inhale valid$Snap$Unbounded(_6$snapshot$0)
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(_6$snapshot$0,
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(0)))))
  // Prepare lifetimes for block bb1
  old_lft_22_0$snapshot$1 := lft_22$snapshot$1
  inhale valid$Snap$ref$Shared$Unbounded(_4$snapshot$1)
  bor_shorten$ref$Shared$Unbounded(lft_22$snapshot$1, old_lft_22_0$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_4$place()),
    destructor$Snap$ref$Shared$Unbounded$$address(_4$snapshot$1), destructor$Snap$ref$Shared$Unbounded$$target_current(_4$snapshot$1))
  goto label_bb1
  label label_bb1
  label_bb1$marker := true
  inhale basic_block_marker$label_bb1$marker()
  // Prepare lifetimes for statement mid bb1[0]
  bw1$snapshot$0 := newlft()
  lft_23$snapshot$1 := bw1$snapshot$0
  lft_4$snapshot$1 := bw1$snapshot$0
  // bb1[0] _5 = &_6
  tmp$1 := assign$ref$Shared$Unbounded$Ref$Unbounded$$lft_4$$(_5$place(), _5$address,
    _6$place(), _6$address, _6$snapshot$0, lft_4$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _5$snapshot$1 == tmp$1
  inhale _6$snapshot$1 ==
    destructor$Snap$ref$Shared$Unbounded$$target_current(tmp$1)
  // Prepare lifetimes for statement mid bb1[1]
  lft_43$snapshot$1 := bw0$snapshot$0
  lft_44$snapshot$1 := bw1$snapshot$0
  // bb1[1] _3 = <prusti_contracts::Int as std::cmp::PartialEq>::eq(move _4, move _5) -> [return: bb2, unwind: bb24]
  consume$Move$ref$Shared$Unbounded(_4$place(), _4$address, _4$snapshot$1, lft_22$alive$snapshot$0,
    lft_22$snapshot$1)
  consume$Move$ref$Shared$Unbounded(_5$place(), _5$address, _5$snapshot$1, lft_23$alive$snapshot$0,
    lft_23$snapshot$1)
  exhale true
  inhale valid$Snap$Bool(_3$snapshot$0)
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Bool(_3$snapshot$0,
    constructor$Snap$Bool$EqCmp_ref$Shared$Unbounded(_4$snapshot$1, _5$snapshot$1)))
  // Prepare lifetimes for block bb2
  endlft(bw0$snapshot$0)
  endlft(bw1$snapshot$0)
  dead_inclusion(lft_22$snapshot$1, bw0$snapshot$0)
  dead_inclusion(lft_23$snapshot$1, bw1$snapshot$0)
  dead_inclusion(lft_4$snapshot$1, bw1$snapshot$0)
  dead_inclusion(lft_43$snapshot$1, bw0$snapshot$0)
  dead_inclusion(lft_44$snapshot$1, bw1$snapshot$0)
  goto label_bb2
  label label_bb2
  label_bb2$marker := true
  inhale basic_block_marker$label_bb2$marker()
  // Prepare lifetimes for statement mid bb2[0]
  // bb2[0] StorageDead(_6)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb2[1]
  // Prepare lifetimes for statement mid bb2[1]
  // bb2[1] StorageDead(_5)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb2[2]
  // Prepare lifetimes for statement mid bb2[2]
  // bb2[2] StorageDead(_4)
  exhale true
  exhale true
  // Prepare lifetimes for statement mid bb2[3]
  // bb2[3] switchInt(move _3) -> [0: bb5, otherwise: bb3]
  if (!destructor$Snap$Bool$$value(_3$snapshot$0)) {
    goto label_2_custom
  }
  if (true) {
    goto label_3_custom
  }
  assert false
  label label_3_custom
  label_3_custom$marker := true
  inhale basic_block_marker$label_3_custom$marker()
  // Prepare lifetimes for block bb3
  goto label_bb3
  label label_bb3
  label_bb3$marker := true
  inhale basic_block_marker$label_bb3$marker()
  // Prepare lifetimes for statement mid bb3[0]
  // bb3[0] StorageLive(_7)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb3[1]
  // Prepare lifetimes for statement mid bb3[1]
  // bb3[1] _7 = ((*_1).0: i64)
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_1$snapshot$0)
  inhale valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))
  tmp_frac_ref_perm$14$snapshot$0 := frac_bor_atomic_acc$I64(lft_21$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, field_place$$struct$m_LinkedList$$$f$val(deref_reference_place(_1$place())),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_1$snapshot$0),
    destructor$Snap$struct$m_LinkedList$$$f$val(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0)))
  inhale _7$snapshot$1 ==
    destructor$Snap$struct$m_LinkedList$$$f$val(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))
  // Prepare lifetimes for statement mid bb3[2]
  // bb3[2] _0 = prusti_contracts::Int::new(move _7) -> [return: bb4, unwind: bb24]
  consume$Move$I64(_7$place(), _7$address, _7$snapshot$1)
  exhale true
  inhale valid$Snap$Unbounded(_0$snapshot$0)
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(_0$snapshot$0,
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(_7$snapshot$1))))
  // Prepare lifetimes for block bb4
  goto label_bb4
  label label__from__label_bb4__to__label_bb23
  inhale _13$snapshot$2 == _13$snapshot$0
  inhale _14$snapshot$2 == _14$snapshot$0
  inhale _17$snapshot$2 == _17$snapshot$0
  inhale _18$snapshot$2 == _18$snapshot$0
  inhale _24$snapshot$2 == _24$snapshot$0
  inhale _25$snapshot$2 == _25$snapshot$0
  inhale _27$snapshot$2 == _27$snapshot$0
  inhale _29$snapshot$2 == _29$snapshot$0
  inhale _7$snapshot$2 == _7$snapshot$1
  inhale _8$snapshot$2 == _8$snapshot$0
  inhale _9$snapshot$2 == _9$snapshot$0
  inhale lft_13$snapshot$2 == lft_13$snapshot$0
  inhale lft_14$snapshot$2 == lft_14$snapshot$0
  inhale lft_15$snapshot$2 == lft_15$snapshot$0
  inhale lft_20$snapshot$2 == lft_20$snapshot$0
  inhale lft_34$snapshot$2 == lft_34$snapshot$0
  inhale lft_39$snapshot$2 == lft_39$snapshot$0
  inhale lft_40$snapshot$2 == lft_40$snapshot$0
  inhale lft_41$snapshot$2 == lft_41$snapshot$0
  inhale lft_42$snapshot$2 == lft_42$snapshot$0
  inhale lft_45$snapshot$2 == lft_45$snapshot$0
  inhale lft_46$snapshot$2 == lft_46$snapshot$0
  inhale lft_function_call_1$snapshot$2 == lft_function_call_1$snapshot$0
  inhale lft_function_call_2$snapshot$2 == lft_function_call_2$snapshot$0
  inhale old_lft_34_2$snapshot$2 == old_lft_34_2$snapshot$0
  inhale old_lft_40_4$snapshot$2 == old_lft_40_4$snapshot$0
  inhale old_lft_40_5$snapshot$2 == old_lft_40_5$snapshot$0
  inhale old_lft_41_3$snapshot$2 == old_lft_41_3$snapshot$0
  goto label_bb23
  label label_bb4
  label_bb4$marker := true
  inhale basic_block_marker$label_bb4$marker()
  // Prepare lifetimes for statement mid bb4[0]
  // bb4[0] StorageDead(_7)
  exhale true
  exhale true
  // Prepare lifetimes for statement mid bb4[1]
  // bb4[1] goto -> bb23
  // Prepare lifetimes for block bb23
  goto label__from__label_bb4__to__label_bb23
  label label_2_custom
  label_2_custom$marker := true
  inhale basic_block_marker$label_2_custom$marker()
  // Prepare lifetimes for block bb5
  goto label_bb5
  label label_bb5
  label_bb5$marker := true
  inhale basic_block_marker$label_bb5$marker()
  // Prepare lifetimes for statement mid bb5[0]
  // bb5[0] StorageLive(_8)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb5[1]
  // Prepare lifetimes for statement mid bb5[1]
  // bb5[1] StorageLive(_9)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb5[2]
  // Prepare lifetimes for statement mid bb5[2]
  // bb5[2] _9 = const false
  inhale _9$snapshot$1 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement mid bb5[3]
  // bb5[3] switchInt(move _9) -> [0: bb7, otherwise: bb6]
  // Specification from block: bb6
  assert !!destructor$Snap$Bool$$value(constructor$Snap$Bool$LeCmp_Unbounded(constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(0))),
    _2$snapshot$1)) &&
    (destructor$Snap$Bool$$value(constructor$Snap$Bool$LtCmp_Unbounded(_2$snapshot$1,
    caller_for$m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))))) &&
    destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(_2$snapshot$1,
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1))))))
  // Prepare lifetimes for block bb7
  goto label_bb7
  label label_bb7
  label_bb7$marker := true
  inhale basic_block_marker$label_bb7$marker()
  // Prepare lifetimes for statement mid bb7[0]
  // bb7[0] _8 = const ()
  inhale _8$snapshot$1 == constructor$Snap$Tuple$$$$()
  // Prepare lifetimes for statement mid bb7[1]
  // bb7[1] goto -> bb8
  // Prepare lifetimes for block bb8
  goto label_bb8
  label label_bb8
  label_bb8$marker := true
  inhale basic_block_marker$label_bb8$marker()
  // Prepare lifetimes for statement mid bb8[0]
  // bb8[0] StorageDead(_9)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb8[1]
  // Prepare lifetimes for statement mid bb8[1]
  // bb8[1] StorageDead(_8)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb8[2]
  // Prepare lifetimes for statement mid bb8[2]
  // bb8[2] StorageLive(_13)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb8[3]
  // Prepare lifetimes for statement mid bb8[3]
  // bb8[3] StorageLive(_14)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb8[4]
  // Prepare lifetimes for statement mid bb8[4]
  // bb8[4] _14 = const false
  inhale _14$snapshot$1 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement mid bb8[5]
  // bb8[5] switchInt(move _14) -> [0: bb10, otherwise: bb9]
  // Specification from block: bb9
  assert destructor$Snap$Bool$$value(constructor$Snap$Bool$GtCmp_Unbounded(caller_for$m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))),
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1)))))
  // Prepare lifetimes for block bb10
  goto label_bb10
  label label_bb10
  label_bb10$marker := true
  inhale basic_block_marker$label_bb10$marker()
  // Prepare lifetimes for statement mid bb10[0]
  // bb10[0] _13 = const ()
  inhale _13$snapshot$1 == constructor$Snap$Tuple$$$$()
  // Prepare lifetimes for statement mid bb10[1]
  // bb10[1] goto -> bb11
  // Prepare lifetimes for block bb11
  goto label_bb11
  label label_bb11
  label_bb11$marker := true
  inhale basic_block_marker$label_bb11$marker()
  // Prepare lifetimes for statement mid bb11[0]
  // bb11[0] StorageDead(_14)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb11[1]
  // Prepare lifetimes for statement mid bb11[1]
  // bb11[1] StorageDead(_13)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb11[2]
  // Prepare lifetimes for statement mid bb11[2]
  // bb11[2] StorageLive(_17)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb11[3]
  // Prepare lifetimes for statement mid bb11[3]
  lft_13$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_34$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb11[3] _17 = &((*_1).1: std::option::Option<BoxWrapper<LinkedList>>)
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_1$snapshot$0)
  inhale valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))
  tmp$2 := assign$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Reborrow$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$lft_13$$(_17$place(),
    _17$address, field_place$$struct$m_LinkedList$$$f$next(deref_reference_place(_1$place())),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_1$snapshot$0),
    destructor$Snap$struct$m_LinkedList$$$f$next(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0)),
    lft_21$snapshot$1, lft_13$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _17$snapshot$1 == tmp$2
  // Prepare lifetimes for statement start bb11[4]
  lft_tok_sep_return$2(lft_13$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // Prepare lifetimes for statement mid bb11[4]
  // bb11[4] FakeRead(ForMatchedPlace(None), _17)
  // encode_statement: not encoded
  // Prepare lifetimes for statement start bb11[5]
  // Prepare lifetimes for statement mid bb11[5]
  // bb11[5] _18 = discriminant((*_17))
  inhale valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_17$snapshot$1)
  tmp_frac_ref_perm$4$snapshot$0 := frac_bor_atomic_acc$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(lft_34$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_17$place()),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(_17$snapshot$1),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1))
  if (false) {
    inhale _18$snapshot$1 ==
      constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1)))
  } else {
    tmp$3 := assign$Isize$Discriminant$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$lft_34$$(_18$place(),
      _18$address, deref_reference_place(_17$place()), destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(_17$snapshot$1),
      tmp_frac_ref_perm$4$snapshot$0, destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1))
    inhale _18$snapshot$1 == tmp$3
  }
  // Prepare lifetimes for statement mid bb11[6]
  // bb11[6] switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb14]
  if (destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Isize(_18$snapshot$1,
  constructor$Snap$Isize$(0)))) {
    goto label_5_custom
  }
  if (destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Isize(_18$snapshot$1,
  constructor$Snap$Isize$(1)))) {
    goto label_6_custom
  }
  if (true) {
    goto label_7_custom
  }
  assert false
  label label_7_custom
  label_7_custom$marker := true
  inhale basic_block_marker$label_7_custom$marker()
  // Prepare lifetimes for block bb14
  lft_tok_sep_return$2(lft_34$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  goto label_bb14
  label label__from__label_bb14__to__resume_panic_label
  inhale _19$snapshot$3 == _19$snapshot$0
  inhale _20$snapshot$3 == _20$snapshot$0
  inhale _24$snapshot$4 == _24$snapshot$0
  inhale _25$snapshot$4 == _25$snapshot$0
  inhale _27$snapshot$4 == _27$snapshot$0
  inhale _29$snapshot$4 == _29$snapshot$0
  inhale lft_14$snapshot$4 == lft_14$snapshot$0
  inhale lft_15$snapshot$4 == lft_15$snapshot$0
  inhale lft_20$snapshot$4 == lft_20$snapshot$0
  inhale lft_39$snapshot$4 == lft_39$snapshot$0
  inhale lft_40$snapshot$4 == lft_40$snapshot$0
  inhale lft_41$snapshot$4 == lft_41$snapshot$0
  inhale lft_42$snapshot$4 == lft_42$snapshot$0
  inhale lft_45$snapshot$4 == lft_45$snapshot$0
  inhale lft_46$snapshot$4 == lft_46$snapshot$0
  inhale lft_function_call_1$snapshot$4 == lft_function_call_1$snapshot$0
  inhale lft_function_call_2$snapshot$4 == lft_function_call_2$snapshot$0
  inhale old_lft_34_1$snapshot$3 == old_lft_34_1$snapshot$0
  inhale old_lft_34_2$snapshot$4 == old_lft_34_2$snapshot$0
  inhale old_lft_40_4$snapshot$4 == old_lft_40_4$snapshot$0
  inhale old_lft_40_5$snapshot$4 == old_lft_40_5$snapshot$0
  inhale old_lft_41_3$snapshot$4 == old_lft_41_3$snapshot$0
  goto resume_panic_label
  label label_bb14
  label_bb14$marker := true
  inhale basic_block_marker$label_bb14$marker()
  // Prepare lifetimes for statement mid bb14[0]
  // bb14[0] unreachable
  // Target marked as unreachable by the compiler
  assert false
  goto label__from__label_bb14__to__resume_panic_label
  label label_6_custom
  label_6_custom$marker := true
  inhale basic_block_marker$label_6_custom$marker()
  // Prepare lifetimes for block bb13
  old_lft_34_2$snapshot$1 := lft_34$snapshot$1
  bor_shorten$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(lft_34$snapshot$1,
    old_lft_34_2$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_17$place()),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(_17$snapshot$1),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1))
  goto label_bb13
  label label_bb13
  label_bb13$marker := true
  inhale basic_block_marker$label_bb13$marker()
  // Prepare lifetimes for statement mid bb13[0]
  // bb13[0] StorageLive(_24)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb13[1]
  // Prepare lifetimes for statement mid bb13[1]
  lft_14$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_39$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb13[1] _24 = &(((*_17) as Some).0: BoxWrapper<LinkedList>)
  inhale valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1)) &&
    (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1)) ==
    0 ||
    discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1)) ==
    1)
  inhale valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1)))
  tmp$4 := assign$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$Reborrow$trusted$m_BoxWrapper$struct$m_LinkedList$$$$lft_14$$(_24$place(),
    _24$address, field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(deref_reference_place(_17$place()))),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(_17$snapshot$1),
    destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1))),
    lft_34$snapshot$1, lft_14$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _24$snapshot$1 == tmp$4
  // Prepare lifetimes for statement start bb13[2]
  lft_tok_sep_return$2(lft_14$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_34$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // Prepare lifetimes for statement mid bb13[2]
  // bb13[2] StorageLive(_25)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb13[3]
  // Prepare lifetimes for statement mid bb13[3]
  // bb13[3] StorageLive(_26)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb13[4]
  // Prepare lifetimes for statement mid bb13[4]
  // bb13[4] StorageLive(_27)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb13[5]
  // Prepare lifetimes for statement mid bb13[5]
  lft_15$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_42$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb13[5] _27 = &(*_24)
  inhale valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(_24$snapshot$1)
  tmp$5 := assign$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$Reborrow$trusted$m_BoxWrapper$struct$m_LinkedList$$$$lft_15$$(_27$place(),
    _27$address, deref_reference_place(_24$place()), destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(_24$snapshot$1),
    destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(_24$snapshot$1),
    lft_39$snapshot$1, lft_15$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _27$snapshot$1 == tmp$5
  exhale true
  // Prepare lifetimes for statement mid bb13[6]
  lft_tok_sep_return$2(lft_15$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_39$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_41$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_45$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb13[6] _26 = BoxWrapper::<LinkedList>::deref(move _27) -> [return: bb19, unwind: bb24]
  lft_function_call_1$snapshot$1 := lft_tok_sep_take$2(lft_2$snapshot$1, lft_42$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  assert included(lft_45$snapshot$1, lft_42$snapshot$1)
  consume$Move$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(_27$place(),
    _27$address, _27$snapshot$1, lft_42$alive$snapshot$0, lft_42$snapshot$1)
  exhale true
  exhale true
  exhale true
  exhale true
  if (tmp$6) {
    goto label_9_custom
  }
  if (!tmp$6) {
    goto label_10_custom
  }
  assert false
  label label_9_custom
  label_9_custom$marker := true
  inhale basic_block_marker$label_9_custom$marker()
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_26$snapshot$0)
  inhale true
  inhale true
  inhale true
  lft_tok_sep_return$2(lft_function_call_1$snapshot$1, lft_2$snapshot$1, lft_42$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  // Prepare lifetimes for block bb19
  old_lft_41_3$snapshot$1 := lft_41$snapshot$1
  lft_tok_sep_return$2(lft_42$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_45$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_26$snapshot$0)
  bor_shorten$ref$Shared$struct$m_LinkedList$(lft_41$snapshot$1, old_lft_41_3$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_26$place()),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_26$snapshot$0),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_26$snapshot$0))
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_ref$Shared$struct$m_LinkedList$(_26$snapshot$0,
    caller_for$m_BoxWrapper$$$openang$T$closeang$$$deref$struct$m_LinkedList$$(_27$snapshot$1)))
  goto label_bb19
  label label_bb19
  label_bb19$marker := true
  inhale basic_block_marker$label_bb19$marker()
  // Prepare lifetimes for statement mid bb19[0]
  lft_20$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_40$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb19[0] _25 = &(*_26)
  tmp$7 := assign$ref$Shared$struct$m_LinkedList$$Reborrow$struct$m_LinkedList$$$lft_20$$(_25$place(),
    _25$address, deref_reference_place(_26$place()), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_26$snapshot$0),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_26$snapshot$0),
    lft_41$snapshot$1, lft_20$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  inhale _25$snapshot$1 == tmp$7
  exhale true
  // Prepare lifetimes for statement start bb19[1]
  lft_tok_sep_return$2(lft_20$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_41$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // Prepare lifetimes for statement mid bb19[1]
  // bb19[1] StorageDead(_27)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb19[2]
  // Prepare lifetimes for statement mid bb19[2]
  // bb19[2] StorageLive(_28)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb19[3]
  // Prepare lifetimes for statement mid bb19[3]
  // bb19[3] StorageLive(_29)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb19[4]
  // Prepare lifetimes for statement mid bb19[4]
  // bb19[4] _29 = _2
  inhale _29$snapshot$1 == _2$snapshot$1
  // Prepare lifetimes for statement start bb19[5]
  // Prepare lifetimes for statement mid bb19[5]
  // bb19[5] StorageLive(_30)
  inhale true
  inhale true
  // Prepare lifetimes for statement mid bb19[6]
  // bb19[6] _30 = prusti_contracts::Int::new(const 1_i64) -> [return: bb20, unwind: bb24]
  consume$Constant$I64(constructor$Snap$I64$(1))
  exhale true
  inhale valid$Snap$Unbounded(_30$snapshot$0)
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(_30$snapshot$0,
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1)))))
  // Prepare lifetimes for block bb20
  old_lft_40_4$snapshot$1 := lft_40$snapshot$1
  inhale valid$Snap$ref$Shared$struct$m_LinkedList$(_25$snapshot$1)
  bor_shorten$ref$Shared$struct$m_LinkedList$(lft_40$snapshot$1, old_lft_40_4$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_25$place()),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_25$snapshot$1),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_25$snapshot$1))
  goto label_bb20
  label label_bb20
  label_bb20$marker := true
  inhale basic_block_marker$label_bb20$marker()
  // Prepare lifetimes for statement mid bb20[0]
  // bb20[0] _28 = <prusti_contracts::Int as std::ops::Sub>::sub(move _29, move _30) -> [return: bb21, unwind: bb24]
  consume$Move$Unbounded(_29$place(), _29$address, _29$snapshot$1)
  consume$Move$Unbounded(_30$place(), _30$address, _30$snapshot$0)
  exhale true
  inhale valid$Snap$Unbounded(_28$snapshot$0)
  inhale destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(_28$snapshot$0,
    constructor$Snap$Unbounded$Sub_Unbounded(_29$snapshot$1, _30$snapshot$0)))
  // Prepare lifetimes for block bb21
  old_lft_40_5$snapshot$1 := lft_40$snapshot$1
  bor_shorten$ref$Shared$struct$m_LinkedList$(lft_40$snapshot$1, old_lft_40_5$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_25$place()),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(_25$snapshot$1),
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_25$snapshot$1))
  goto label_bb21
  label label_bb21
  label_bb21$marker := true
  inhale basic_block_marker$label_bb21$marker()
  // Prepare lifetimes for statement mid bb21[0]
  // bb21[0] StorageDead(_30)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb21[1]
  // Prepare lifetimes for statement mid bb21[1]
  // bb21[1] StorageDead(_29)
  exhale true
  exhale true
  // Prepare lifetimes for statement mid bb21[2]
  lft_46$snapshot$1 := lft_tok_sep_take$2(bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  // bb21[2] _0 = LinkedList::lookup(move _25, move _28) -> [return: bb22, unwind: bb24]
  lft_function_call_2$snapshot$1 := lft_tok_sep_take$2(lft_2$snapshot$1, lft_40$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  assert included(lft_46$snapshot$1, lft_40$snapshot$1)
  consume$Move$ref$Shared$struct$m_LinkedList$(_25$place(), _25$address, _25$snapshot$1,
    lft_40$alive$snapshot$0, lft_40$snapshot$1)
  consume$Move$Unbounded(_28$place(), _28$address, _28$snapshot$0)
  exhale true
  exhale true
  exhale true
  assert destructor$Snap$Bool$$value(constructor$Snap$Bool$GtCmp_Unbounded(termination_var$1$snapshot$1,
    _28$snapshot$0))
  assert destructor$Snap$Bool$$value(constructor$Snap$Bool$GeCmp_Unbounded(termination_var$1$snapshot$1,
    constructor$Snap$Unbounded$(0)))
  assert !!destructor$Snap$Bool$$value(constructor$Snap$Bool$LeCmp_Unbounded(constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(0))),
    _28$snapshot$0)) &&
    destructor$Snap$Bool$$value(constructor$Snap$Bool$LtCmp_Unbounded(_28$snapshot$0,
    caller_for$m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_25$snapshot$1)))))
  exhale true
  if (tmp$8) {
    goto label_12_custom
  }
  if (!tmp$8) {
    goto label_13_custom
  }
  assert false
  label label_5_custom
  label_5_custom$marker := true
  inhale basic_block_marker$label_5_custom$marker()
  // Prepare lifetimes for block bb12
  old_lft_34_1$snapshot$1 := lft_34$snapshot$1
  bor_shorten$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(lft_34$snapshot$1,
    old_lft_34_1$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 / 59, deref_reference_place(_17$place()),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(_17$snapshot$1),
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(_17$snapshot$1))
  goto label_bb12
  label label_bb12
  label_bb12$marker := true
  inhale basic_block_marker$label_bb12$marker()
  // Prepare lifetimes for statement mid bb12[0]
  // bb12[0] falseEdge -> [real: bb15, imaginary: bb13]
  // Prepare lifetimes for block bb15
  lft_tok_sep_return$2(lft_34$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  goto label_bb15
  label label_bb15
  label_bb15$marker := true
  inhale basic_block_marker$label_bb15$marker()
  // Prepare lifetimes for statement mid bb15[0]
  // bb15[0] StorageLive(_19)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb15[1]
  // Prepare lifetimes for statement mid bb15[1]
  // bb15[1] StorageLive(_20)
  inhale true
  inhale true
  // Prepare lifetimes for statement start bb15[2]
  // Prepare lifetimes for statement mid bb15[2]
  // bb15[2] _20 = const false
  inhale _20$snapshot$1 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement mid bb15[3]
  // bb15[3] switchInt(move _20) -> [0: bb17, otherwise: bb16]
  // Specification from block: bb16
  assert destructor$Snap$Bool$$value(constructor$Snap$Bool$EqCmp_Unbounded(caller_for$m_LinkedList$$len$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(_1$snapshot$0))),
    constructor$Snap$Unbounded$(destructor$Snap$I64$$value(constructor$Snap$I64$(1)))))
  // Prepare lifetimes for block bb17
  goto label_bb17
  label label_bb17
  label_bb17$marker := true
  inhale basic_block_marker$label_bb17$marker()
  // Prepare lifetimes for statement mid bb17[0]
  // bb17[0] _19 = const ()
  inhale _19$snapshot$1 == constructor$Snap$Tuple$$$$()
  // Prepare lifetimes for statement mid bb17[1]
  // bb17[1] goto -> bb18
  // Prepare lifetimes for block bb18
  goto label_bb18
  label label__from__label_bb18__to__label_bb24
  inhale _19$snapshot$2 == _19$snapshot$1
  inhale _20$snapshot$2 == _20$snapshot$1
  inhale _24$snapshot$3 == _24$snapshot$0
  inhale _25$snapshot$3 == _25$snapshot$0
  inhale _27$snapshot$3 == _27$snapshot$0
  inhale _29$snapshot$3 == _29$snapshot$0
  inhale lft_14$snapshot$3 == lft_14$snapshot$0
  inhale lft_15$snapshot$3 == lft_15$snapshot$0
  inhale lft_20$snapshot$3 == lft_20$snapshot$0
  inhale lft_39$snapshot$3 == lft_39$snapshot$0
  inhale lft_40$snapshot$3 == lft_40$snapshot$0
  inhale lft_41$snapshot$3 == lft_41$snapshot$0
  inhale lft_42$snapshot$3 == lft_42$snapshot$0
  inhale lft_45$snapshot$3 == lft_45$snapshot$0
  inhale lft_46$snapshot$3 == lft_46$snapshot$0
  inhale lft_function_call_1$snapshot$3 == lft_function_call_1$snapshot$0
  inhale lft_function_call_2$snapshot$3 == lft_function_call_2$snapshot$0
  inhale old_lft_34_1$snapshot$2 == old_lft_34_1$snapshot$1
  inhale old_lft_34_2$snapshot$3 == old_lft_34_2$snapshot$0
  inhale old_lft_40_4$snapshot$3 == old_lft_40_4$snapshot$0
  inhale old_lft_40_5$snapshot$3 == old_lft_40_5$snapshot$0
  inhale old_lft_41_3$snapshot$3 == old_lft_41_3$snapshot$0
  goto label_bb24
  label label_bb18
  label_bb18$marker := true
  inhale basic_block_marker$label_bb18$marker()
  // Prepare lifetimes for statement mid bb18[0]
  // bb18[0] StorageDead(_20)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb18[1]
  // Prepare lifetimes for statement mid bb18[1]
  // bb18[1] StorageDead(_19)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb18[2]
  // Prepare lifetimes for statement mid bb18[2]
  // bb18[2] StorageLive(_23)
  inhale true
  inhale true
  // Prepare lifetimes for statement mid bb18[3]
  // bb18[3] _23 = core::panicking::panic(const "internal error: entered unreachable code") -> bb24
  // Rust panic - const "internal error: entered unreachable code"
  assert false
  goto label__from__label_bb18__to__label_bb24
  label label__from__label_13_custom__to__label_bb24
  inhale _19$snapshot$2 == _19$snapshot$0
  inhale _20$snapshot$2 == _20$snapshot$0
  inhale _24$snapshot$3 == _24$snapshot$1
  inhale _25$snapshot$3 == _25$snapshot$1
  inhale _27$snapshot$3 == _27$snapshot$1
  inhale _29$snapshot$3 == _29$snapshot$1
  inhale lft_14$snapshot$3 == lft_14$snapshot$1
  inhale lft_15$snapshot$3 == lft_15$snapshot$1
  inhale lft_20$snapshot$3 == lft_20$snapshot$1
  inhale lft_39$snapshot$3 == lft_39$snapshot$1
  inhale lft_40$snapshot$3 == lft_40$snapshot$1
  inhale lft_41$snapshot$3 == lft_41$snapshot$1
  inhale lft_42$snapshot$3 == lft_42$snapshot$1
  inhale lft_45$snapshot$3 == lft_45$snapshot$1
  inhale lft_46$snapshot$3 == lft_46$snapshot$1
  inhale lft_function_call_1$snapshot$3 == lft_function_call_1$snapshot$1
  inhale lft_function_call_2$snapshot$3 == lft_function_call_2$snapshot$1
  inhale old_lft_34_1$snapshot$2 == old_lft_34_1$snapshot$0
  inhale old_lft_34_2$snapshot$3 == old_lft_34_2$snapshot$1
  inhale old_lft_40_4$snapshot$3 == old_lft_40_4$snapshot$1
  inhale old_lft_40_5$snapshot$3 == old_lft_40_5$snapshot$1
  inhale old_lft_41_3$snapshot$3 == old_lft_41_3$snapshot$1
  goto label_bb24
  label label_13_custom
  label_13_custom$marker := true
  inhale basic_block_marker$label_13_custom$marker()
  inhale true
  inhale true
  inhale true
  inhale true
  lft_tok_sep_return$2(lft_function_call_2$snapshot$1, lft_2$snapshot$1, lft_40$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  // Prepare lifetimes for block bb24
  lft_tok_sep_return$2(lft_40$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_46$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  goto label__from__label_13_custom__to__label_bb24
  label label_12_custom
  label_12_custom$marker := true
  inhale basic_block_marker$label_12_custom$marker()
  inhale valid$Snap$Unbounded(_0$snapshot$0)
  inhale true
  inhale true
  inhale true
  lft_tok_sep_return$2(lft_function_call_2$snapshot$1, lft_2$snapshot$1, lft_40$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  // Prepare lifetimes for block bb22
  lft_tok_sep_return$2(lft_40$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_46$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  goto label_bb22
  label label__from__label_bb22__to__label_bb23
  inhale _13$snapshot$2 == _13$snapshot$1
  inhale _14$snapshot$2 == _14$snapshot$1
  inhale _17$snapshot$2 == _17$snapshot$1
  inhale _18$snapshot$2 == _18$snapshot$1
  inhale _24$snapshot$2 == _24$snapshot$1
  inhale _25$snapshot$2 == _25$snapshot$1
  inhale _27$snapshot$2 == _27$snapshot$1
  inhale _29$snapshot$2 == _29$snapshot$1
  inhale _7$snapshot$2 == _7$snapshot$0
  inhale _8$snapshot$2 == _8$snapshot$1
  inhale _9$snapshot$2 == _9$snapshot$1
  inhale lft_13$snapshot$2 == lft_13$snapshot$1
  inhale lft_14$snapshot$2 == lft_14$snapshot$1
  inhale lft_15$snapshot$2 == lft_15$snapshot$1
  inhale lft_20$snapshot$2 == lft_20$snapshot$1
  inhale lft_34$snapshot$2 == lft_34$snapshot$1
  inhale lft_39$snapshot$2 == lft_39$snapshot$1
  inhale lft_40$snapshot$2 == lft_40$snapshot$1
  inhale lft_41$snapshot$2 == lft_41$snapshot$1
  inhale lft_42$snapshot$2 == lft_42$snapshot$1
  inhale lft_45$snapshot$2 == lft_45$snapshot$1
  inhale lft_46$snapshot$2 == lft_46$snapshot$1
  inhale lft_function_call_1$snapshot$2 == lft_function_call_1$snapshot$1
  inhale lft_function_call_2$snapshot$2 == lft_function_call_2$snapshot$1
  inhale old_lft_34_2$snapshot$2 == old_lft_34_2$snapshot$1
  inhale old_lft_40_4$snapshot$2 == old_lft_40_4$snapshot$1
  inhale old_lft_40_5$snapshot$2 == old_lft_40_5$snapshot$1
  inhale old_lft_41_3$snapshot$2 == old_lft_41_3$snapshot$1
  goto label_bb23
  label label_bb22
  label_bb22$marker := true
  inhale basic_block_marker$label_bb22$marker()
  // Prepare lifetimes for statement mid bb22[0]
  // bb22[0] StorageDead(_28)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb22[1]
  // Prepare lifetimes for statement mid bb22[1]
  // bb22[1] StorageDead(_25)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb22[2]
  // Prepare lifetimes for statement mid bb22[2]
  // bb22[2] StorageDead(_26)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb22[3]
  // Prepare lifetimes for statement mid bb22[3]
  // bb22[3] StorageDead(_24)
  exhale true
  exhale true
  // Prepare lifetimes for statement start bb22[4]
  // Prepare lifetimes for statement mid bb22[4]
  // bb22[4] StorageDead(_17)
  exhale true
  exhale true
  // Prepare lifetimes for statement mid bb22[5]
  // bb22[5] goto -> bb23
  // Prepare lifetimes for block bb23
  goto label__from__label_bb22__to__label_bb23
  label label_bb23
  label_bb23$marker := true
  inhale basic_block_marker$label_bb23$marker()
  // Prepare lifetimes for statement mid bb23[0]
  // bb23[0] StorageDead(_3)
  if (label_bb22$marker) {
  }
  if (label_bb4$marker) {
  }
  exhale true
  exhale true
  // Prepare lifetimes for statement mid bb23[1]
  // bb23[1] return
  goto return_label
  label label__from__return_label__to__end_label
  inhale _13$snapshot$3 == _13$snapshot$2
  inhale _14$snapshot$3 == _14$snapshot$2
  inhale _17$snapshot$3 == _17$snapshot$2
  inhale _18$snapshot$3 == _18$snapshot$2
  inhale _19$snapshot$4 == _19$snapshot$0
  inhale _20$snapshot$4 == _20$snapshot$0
  inhale _24$snapshot$5 == _24$snapshot$2
  inhale _25$snapshot$5 == _25$snapshot$2
  inhale _27$snapshot$5 == _27$snapshot$2
  inhale _29$snapshot$5 == _29$snapshot$2
  inhale _7$snapshot$3 == _7$snapshot$2
  inhale _8$snapshot$3 == _8$snapshot$2
  inhale _9$snapshot$3 == _9$snapshot$2
  inhale lft_13$snapshot$3 == lft_13$snapshot$2
  inhale lft_14$snapshot$5 == lft_14$snapshot$2
  inhale lft_15$snapshot$5 == lft_15$snapshot$2
  inhale lft_20$snapshot$5 == lft_20$snapshot$2
  inhale lft_34$snapshot$3 == lft_34$snapshot$2
  inhale lft_39$snapshot$5 == lft_39$snapshot$2
  inhale lft_40$snapshot$5 == lft_40$snapshot$2
  inhale lft_41$snapshot$5 == lft_41$snapshot$2
  inhale lft_42$snapshot$5 == lft_42$snapshot$2
  inhale lft_45$snapshot$5 == lft_45$snapshot$2
  inhale lft_46$snapshot$5 == lft_46$snapshot$2
  inhale lft_function_call_1$snapshot$5 == lft_function_call_1$snapshot$2
  inhale lft_function_call_2$snapshot$5 == lft_function_call_2$snapshot$2
  inhale old_lft_34_1$snapshot$4 == old_lft_34_1$snapshot$0
  inhale old_lft_34_2$snapshot$5 == old_lft_34_2$snapshot$2
  inhale old_lft_40_4$snapshot$5 == old_lft_40_4$snapshot$2
  inhale old_lft_40_5$snapshot$5 == old_lft_40_5$snapshot$2
  inhale old_lft_41_3$snapshot$5 == old_lft_41_3$snapshot$2
  goto end_label
  label return_label
  return_label$marker := true
  inhale basic_block_marker$return_label$marker()
  // Assert functional postconditions.
  // Deallocate the parameters.
  exhale true
  if (label_bb22$marker && label_bb23$marker) {
  }
  if (label_bb4$marker && label_bb23$marker) {
  }
  if (label_bb4$marker && label_bb23$marker) {
  }
  exhale true
  // Deallocate the return place.
  exhale valid$Snap$Unbounded(_0$snapshot$0)
  // Lifetime postconditions.
  lft_tok_sep_return$2(lft_1$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$3(lft_2$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, bw8$snapshot$0,
    lifetime_token_perm_amount$0$snapshot$0 / 59)
  lft_tok_sep_return$2(lft_21$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  exhale true
  exhale true
  exhale true
  if (label_bb22$marker && label_bb23$marker) {
  }
  exhale true
  goto label__from__return_label__to__end_label
  label label__from__label_10_custom__to__label_bb24
  inhale _19$snapshot$2 == _19$snapshot$0
  inhale _20$snapshot$2 == _20$snapshot$0
  inhale _24$snapshot$3 == _24$snapshot$1
  inhale _25$snapshot$3 == _25$snapshot$0
  inhale _27$snapshot$3 == _27$snapshot$1
  inhale _29$snapshot$3 == _29$snapshot$0
  inhale lft_14$snapshot$3 == lft_14$snapshot$1
  inhale lft_15$snapshot$3 == lft_15$snapshot$1
  inhale lft_20$snapshot$3 == lft_20$snapshot$0
  inhale lft_39$snapshot$3 == lft_39$snapshot$1
  inhale lft_40$snapshot$3 == lft_40$snapshot$0
  inhale lft_41$snapshot$3 == lft_41$snapshot$1
  inhale lft_42$snapshot$3 == lft_42$snapshot$1
  inhale lft_45$snapshot$3 == lft_45$snapshot$1
  inhale lft_46$snapshot$3 == lft_46$snapshot$0
  inhale lft_function_call_1$snapshot$3 == lft_function_call_1$snapshot$1
  inhale lft_function_call_2$snapshot$3 == lft_function_call_2$snapshot$0
  inhale old_lft_34_1$snapshot$2 == old_lft_34_1$snapshot$0
  inhale old_lft_34_2$snapshot$3 == old_lft_34_2$snapshot$1
  inhale old_lft_40_4$snapshot$3 == old_lft_40_4$snapshot$0
  inhale old_lft_40_5$snapshot$3 == old_lft_40_5$snapshot$0
  inhale old_lft_41_3$snapshot$3 == old_lft_41_3$snapshot$0
  goto label_bb24
  label label_10_custom
  label_10_custom$marker := true
  inhale basic_block_marker$label_10_custom$marker()
  inhale true
  inhale true
  inhale true
  inhale true
  lft_tok_sep_return$2(lft_function_call_1$snapshot$1, lft_2$snapshot$1, lft_42$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 118)
  // Prepare lifetimes for block bb24
  lft_tok_sep_return$2(lft_41$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_42$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  lft_tok_sep_return$2(lft_45$snapshot$1, bw6$snapshot$0, bw7$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    59)
  goto label__from__label_10_custom__to__label_bb24
  label label__from__label_bb24__to__resume_panic_label
  inhale _19$snapshot$3 == _19$snapshot$2
  inhale _20$snapshot$3 == _20$snapshot$2
  inhale _24$snapshot$4 == _24$snapshot$3
  inhale _25$snapshot$4 == _25$snapshot$3
  inhale _27$snapshot$4 == _27$snapshot$3
  inhale _29$snapshot$4 == _29$snapshot$3
  inhale lft_14$snapshot$4 == lft_14$snapshot$3
  inhale lft_15$snapshot$4 == lft_15$snapshot$3
  inhale lft_20$snapshot$4 == lft_20$snapshot$3
  inhale lft_39$snapshot$4 == lft_39$snapshot$3
  inhale lft_40$snapshot$4 == lft_40$snapshot$3
  inhale lft_41$snapshot$4 == lft_41$snapshot$3
  inhale lft_42$snapshot$4 == lft_42$snapshot$3
  inhale lft_45$snapshot$4 == lft_45$snapshot$3
  inhale lft_46$snapshot$4 == lft_46$snapshot$3
  inhale lft_function_call_1$snapshot$4 == lft_function_call_1$snapshot$3
  inhale lft_function_call_2$snapshot$4 == lft_function_call_2$snapshot$3
  inhale old_lft_34_1$snapshot$3 == old_lft_34_1$snapshot$2
  inhale old_lft_34_2$snapshot$4 == old_lft_34_2$snapshot$3
  inhale old_lft_40_4$snapshot$4 == old_lft_40_4$snapshot$3
  inhale old_lft_40_5$snapshot$4 == old_lft_40_5$snapshot$3
  inhale old_lft_41_3$snapshot$4 == old_lft_41_3$snapshot$3
  goto resume_panic_label
  label label_bb24
  label_bb24$marker := true
  inhale basic_block_marker$label_bb24$marker()
  // Prepare lifetimes for statement mid bb24[0]
  // bb24[0] resume
  goto label__from__label_bb24__to__resume_panic_label
  label label__from__resume_panic_label__to__end_label
  inhale _13$snapshot$3 == _13$snapshot$1
  inhale _14$snapshot$3 == _14$snapshot$1
  inhale _17$snapshot$3 == _17$snapshot$1
  inhale _18$snapshot$3 == _18$snapshot$1
  inhale _19$snapshot$4 == _19$snapshot$3
  inhale _20$snapshot$4 == _20$snapshot$3
  inhale _24$snapshot$5 == _24$snapshot$4
  inhale _25$snapshot$5 == _25$snapshot$4
  inhale _27$snapshot$5 == _27$snapshot$4
  inhale _29$snapshot$5 == _29$snapshot$4
  inhale _7$snapshot$3 == _7$snapshot$0
  inhale _8$snapshot$3 == _8$snapshot$1
  inhale _9$snapshot$3 == _9$snapshot$1
  inhale lft_13$snapshot$3 == lft_13$snapshot$1
  inhale lft_14$snapshot$5 == lft_14$snapshot$4
  inhale lft_15$snapshot$5 == lft_15$snapshot$4
  inhale lft_20$snapshot$5 == lft_20$snapshot$4
  inhale lft_34$snapshot$3 == lft_34$snapshot$1
  inhale lft_39$snapshot$5 == lft_39$snapshot$4
  inhale lft_40$snapshot$5 == lft_40$snapshot$4
  inhale lft_41$snapshot$5 == lft_41$snapshot$4
  inhale lft_42$snapshot$5 == lft_42$snapshot$4
  inhale lft_45$snapshot$5 == lft_45$snapshot$4
  inhale lft_46$snapshot$5 == lft_46$snapshot$4
  inhale lft_function_call_1$snapshot$5 == lft_function_call_1$snapshot$4
  inhale lft_function_call_2$snapshot$5 == lft_function_call_2$snapshot$4
  inhale old_lft_34_1$snapshot$4 == old_lft_34_1$snapshot$3
  inhale old_lft_34_2$snapshot$5 == old_lft_34_2$snapshot$4
  inhale old_lft_40_4$snapshot$5 == old_lft_40_4$snapshot$4
  inhale old_lft_40_5$snapshot$5 == old_lft_40_5$snapshot$4
  inhale old_lft_41_3$snapshot$5 == old_lft_41_3$snapshot$4
  goto end_label
  label resume_panic_label
  resume_panic_label$marker := true
  inhale basic_block_marker$resume_panic_label$marker()
  goto label__from__resume_panic_label__to__end_label
  label end_label
  end_label$marker := true
  inhale basic_block_marker$end_label$marker()
  goto end_of_method
  label end_of_method
}

method assign$Isize$Discriminant$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$lft_34$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_address: Address, operand_permission: Perm,
  operand_value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  returns (result_value: Snap$Isize)
  requires true
  requires none < operand_permission
  requires true
  requires valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(operand_value)
  ensures true
  ensures true
  ensures result_value ==
    constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(operand_value))
  ensures valid$Snap$Isize(result_value)


method assign$ref$Shared$Unbounded$Ref$Unbounded$$lft_3$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot: Snap$Unbounded, lft_3: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$Unbounded)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires true
  requires true
  requires valid$Snap$Unbounded(operand_snapshot)
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$Unbounded$$address(result_value)
  ensures operand_snapshot ==
    destructor$Snap$ref$Shared$Unbounded$$target_current(result_value)
  ensures true
  ensures true
  ensures true --*
    valid$Snap$Unbounded(destructor$Snap$ref$Shared$Unbounded$$target_current(result_value))
  ensures valid$Snap$ref$Shared$Unbounded(result_value)


method assign$ref$Shared$Unbounded$Ref$Unbounded$$lft_4$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot: Snap$Unbounded, lft_4: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$Unbounded)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires true
  requires true
  requires valid$Snap$Unbounded(operand_snapshot)
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$Unbounded$$address(result_value)
  ensures operand_snapshot ==
    destructor$Snap$ref$Shared$Unbounded$$target_current(result_value)
  ensures true
  ensures true
  ensures true --*
    valid$Snap$Unbounded(destructor$Snap$ref$Shared$Unbounded$$target_current(result_value))
  ensures valid$Snap$ref$Shared$Unbounded(result_value)


method assign$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Reborrow$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$lft_13$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot_current: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$,
  lft_21: Lifetime, lft_13: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft_13, lft_21)
  requires true
  requires true
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$address(result_value)
  ensures operand_snapshot_current ==
    destructor$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$target_current(result_value)
  ensures true
  ensures true
  ensures valid$Snap$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(result_value)
  ensures true


method assign$ref$Shared$struct$m_LinkedList$$Reborrow$struct$m_LinkedList$$$lft_20$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot_current: Snap$struct$m_LinkedList$, lft_41: Lifetime, lft_20: Lifetime,
  lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$struct$m_LinkedList$)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft_20, lft_41)
  requires true
  requires true
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(result_value)
  ensures operand_snapshot_current ==
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(result_value)
  ensures true
  ensures true
  ensures valid$Snap$ref$Shared$struct$m_LinkedList$(result_value)
  ensures true


method assign$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$Reborrow$trusted$m_BoxWrapper$struct$m_LinkedList$$$$lft_14$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$,
  lft_34: Lifetime, lft_14: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft_14, lft_34)
  requires true
  requires true
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(result_value)
  ensures operand_snapshot_current ==
    destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(result_value)
  ensures true
  ensures true
  ensures valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(result_value)
  ensures true


method assign$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$Reborrow$trusted$m_BoxWrapper$struct$m_LinkedList$$$$lft_15$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot_current: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$,
  lft_39: Lifetime, lft_15: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$)
  requires true
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft_15, lft_39)
  requires true
  requires true
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$address(result_value)
  ensures operand_snapshot_current ==
    destructor$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$$$target_current(result_value)
  ensures true
  ensures true
  ensures valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(result_value)
  ensures true


method bor_shorten$ref$Shared$Unbounded(lft: Lifetime, old_lft: Lifetime, lifetime_perm: Perm,
  place: Place, root_address: Address, current_snapshot: Snap$Unbounded)
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft, old_lft)
  requires true
  requires true
  ensures true
  ensures true


method bor_shorten$ref$Shared$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(lft: Lifetime,
  old_lft: Lifetime, lifetime_perm: Perm, place: Place, root_address: Address,
  current_snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft, old_lft)
  requires true
  requires true
  ensures true
  ensures true


method bor_shorten$ref$Shared$struct$m_LinkedList$(lft: Lifetime, old_lft: Lifetime,
  lifetime_perm: Perm, place: Place, root_address: Address, current_snapshot: Snap$struct$m_LinkedList$)
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires included(lft, old_lft)
  requires true
  requires true
  ensures true
  ensures true


method consume$Constant$I64(operand1_value: Snap$I64)
  requires valid$Snap$I64(operand1_value)


method consume$Move$I64(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$I64)
  requires true
  requires valid$Snap$I64(operand1_value)
  ensures true


method consume$Move$Unbounded(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$Unbounded)
  requires true
  requires valid$Snap$Unbounded(operand1_value)
  ensures true


method consume$Move$ref$Shared$Unbounded(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$ref$Shared$Unbounded, lft_22$alive: Bool, lft_22: Lifetime)
  requires true
  requires valid$Snap$ref$Shared$Unbounded(operand1_value)
  ensures true


method consume$Move$ref$Shared$struct$m_LinkedList$(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$ref$Shared$struct$m_LinkedList$, lft_40$alive: Bool,
  lft_40: Lifetime)
  requires true
  requires valid$Snap$ref$Shared$struct$m_LinkedList$(operand1_value)
  ensures true


method consume$Move$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(operand1_place: Place,
  operand1_root_address: Address, operand1_value: Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$,
  lft_42$alive: Bool, lft_42: Lifetime)
  requires true
  requires valid$Snap$ref$Shared$trusted$m_BoxWrapper$struct$m_LinkedList$$(operand1_value)
  ensures true


method dead_inclusion(lft_1: Lifetime, lft_2: Lifetime)
  requires true
  requires included(lft_1, lft_2)
  ensures true
  ensures true


method endlft(bw: Lifetime)
  requires true
  ensures true


method frac_bor_atomic_acc$I64(lifetime: Lifetime, lifetime_perm: Perm, place: Place,
  root_address: Address, current_snapshot: Snap$I64)
  returns (owned_perm: Perm)
  requires none < lifetime_perm
  requires true
  requires true
  ensures owned_perm < write
  ensures none < owned_perm
  ensures true
  ensures true --* true


method frac_bor_atomic_acc$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(lifetime: Lifetime,
  lifetime_perm: Perm, place: Place, root_address: Address, current_snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  returns (owned_perm: Perm)
  requires none < lifetime_perm
  requires true
  requires true
  ensures owned_perm < write
  ensures none < owned_perm
  ensures true
  ensures true --* true


method lft_tok_sep_return$2(lft: Lifetime, lft_1: Lifetime, lft_2: Lifetime,
  rd_perm: Perm)
  requires none < rd_perm
  requires true
  requires lft == intersect(Set(lft_1, lft_2))
  ensures true
  ensures true


method lft_tok_sep_return$3(lft: Lifetime, lft_1: Lifetime, lft_2: Lifetime,
  lft_3: Lifetime, rd_perm: Perm)
  requires none < rd_perm
  requires true
  requires lft == intersect(Set(lft_1, lft_2, lft_3))
  ensures true
  ensures true
  ensures true


method lft_tok_sep_take$2(lft_1: Lifetime, lft_2: Lifetime, rd_perm: Perm)
  returns (lft: Lifetime)
  requires none < rd_perm
  requires true
  requires true
  ensures true
  ensures lft == intersect(Set(lft_1, lft_2))


method lft_tok_sep_take$3(lft_1: Lifetime, lft_2: Lifetime, lft_3: Lifetime,
  rd_perm: Perm)
  returns (lft: Lifetime)
  requires none < rd_perm
  requires true
  requires true
  requires true
  ensures true
  ensures lft == intersect(Set(lft_1, lft_2, lft_3))


method newlft() returns (bw: Lifetime)
  ensures true
