// Generated on 2024-01-05 at 15:52:58
domain TYPE {
  
  unique function class_ParallelASSSPLemmas(): TYPE
  
  unique function class_java_DOT_lang_DOT_Object(): TYPE
  
  unique function class_EncodedGlobalVariables(): TYPE
  
  function directSuperclass(t: TYPE): TYPE
  
  function type_of(val: Ref): TYPE
  
  axiom ParallelASSSPLemmas_directSuperclass {
    directSuperclass(class_ParallelASSSPLemmas()) == class_java_DOT_lang_DOT_Object()
  }
  
  axiom EncodedGlobalVariables_directSuperclass {
    directSuperclass(class_EncodedGlobalVariables()) == class_java_DOT_lang_DOT_Object()
  }
}

function ParallelASSSPLemmas_inf(): Int
{
  -1
}

function ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int]): Bool
{
  0 < V && 0 < A && |start| == A && |end| == A && |weight| == A && ((forall i: Int :: { start[i] } 0 <= i && i < A ==> 0 <= start[i] && start[i] < V) && (forall i: Int :: { end[i] } 0 <= i && i < A ==> 0 <= end[i]) && (forall i: Int :: { end[i] } 0 <= i && i < A ==> end[i] < V) && (forall i: Int :: { start[i] } { end[i] } 0 <= i && i < A ==> start[i] != end[i]) && (forall i: Int, j: Int :: 0 <= i && i < A && (0 <= j && j < A && i != j && start[i] == start[j]) ==> end[i] != end[j]) && (forall i: Int :: { weight[i] } 0 <= i && i < A ==> 0 < weight[i]))
}

function ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  decreases _
  ensures (forall i: Int :: 0 <= i && i < A ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, start[i], end[i], Seq(i)))
{
  0 <= x && x < V && 0 <= y && y < V && (forall i: Int :: { P[i] } 0 <= i && i < |P| ==> 0 <= P[i] && P[i] < A) && (0 == |P| ==> x == y) && (0 < |P| ==> start[P[0]] == x && end[P[|P| - 1]] == y) && (forall i: Int :: 0 <= i && i < |P| - 1 ==> end[P[i]] == start[P[i + 1]])
}

function ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  decreases _
  ensures (forall i: Int :: 0 <= i && i < A ==> ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, start[i], end[i], Seq(i)))
{
  ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) && (forall i: Int, j: Int :: 0 <= i && i < |P| - 1 && (i < j && j < |P|) ==> start[P[i]] != end[P[j]])
}

function ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, len: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
{
  (exists P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) && |P| <= len)
}

function ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, len: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  decreases _
  ensures (forall i: Int :: 0 <= i && i < A ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, start[i], end[i], weight[i]))
  ensures ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, x, x, 0)
{
  (exists P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) == len)
}

function ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], P: Seq[Int]): Int
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires (forall i: Int :: { P[i] } 0 <= i && i < |P| ==> 0 <= P[i] && P[i] < A)
  ensures 0 <= result
  ensures 0 == |P| ==> result == 0
  ensures P != Seq[Int]() ==> 0 < result
  ensures result == 0 ==> P == Seq[Int]()
  ensures result != 0 ==> P != Seq[Int]()
  ensures 1 == |P| ==> result == weight[P[0]]
{
  (0 < |P| ? weight[P[0]] + ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P[1..]) : 0)
}

function ParallelASSSPLemmas_lemma_path_append_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int], a: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  requires 0 <= a && a < A
  requires end[a] == x
  ensures result && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, start[a], y, Seq(a) ++ P)


function ParallelASSSPLemmas_lemma_path_trans_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], s: Int, t: Int, u: Int, P: Seq[Int], Q: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, s, t, P)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, t, u, Q)
  ensures result && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, s, u, P ++ Q)
{
  0 < |P| ==> ParallelASSSPLemmas_lemma_path_trans_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, end[P[0]], t, u, P[1..], Q) && ParallelASSSPLemmas_lemma_path_append_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$_Integer(V, A, start, end, weight, end[P[0]], u, P[1..] ++ Q, P[0]) && ParallelASSSPLemmas_iseq_assoc_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(Seq(P[0]), P[1..], Q) && Seq(P[0]) ++ P[1..] == P
}

function ParallelASSSPLemmas_lemma_app_nonempty_Sequence$Integer$_Sequence$Integer$(xs: Seq[Int], ys: Seq[Int]): Bool
  requires 0 < |xs|
  ensures (xs ++ ys)[0] == xs[0]
  ensures (xs ++ ys)[1..] == xs[1..] ++ ys
  ensures result
{
  true
}

function ParallelASSSPLemmas_iseq_assoc_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(xs: Seq[Int], ys: Seq[Int], zs: Seq[Int]): Bool
  ensures xs ++ ys ++ zs == xs ++ (ys ++ zs)
  ensures result
{
  true
}

function ParallelASSSPLemmas_lemma_app_append_right_Sequence$Integer$_Sequence$Integer$(xs: Seq[Int], ys: Seq[Int]): Bool
  requires 0 < |ys|
  ensures xs ++ Seq(ys[0]) ++ ys[1..] == xs ++ (Seq(ys[0]) ++ ys[1..])
  ensures ys == Seq(ys[0]) ++ ys[1..]
  ensures result && xs ++ Seq(ys[0]) ++ ys[1..] == xs ++ ys
{
  ParallelASSSPLemmas_iseq_assoc_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(xs, Seq(ys[0]), ys[1..])
}

function ParallelASSSPLemmas_lemma_cost_app_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], P: Seq[Int], Q: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires (forall i: Int :: { P[i] } 0 <= i && i < |P| ==> 0 <= P[i] && P[i] < A)
  requires (forall i: Int :: { Q[i] } 0 <= i && i < |Q| ==> 0 <= Q[i] && Q[i] < A)
  ensures result && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P ++ Q) == ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) + ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, Q)
{
  0 < |P| ==> ParallelASSSPLemmas_lemma_app_nonempty_Sequence$Integer$_Sequence$Integer$(P, Q) && ParallelASSSPLemmas_lemma_cost_app_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P[1..], Q)
}

function ParallelASSSPLemmas_lemma_cost_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], s: Int, t: Int, u: Int, P: Seq[Int], Q: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, s, t, P)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, t, u, Q)
  ensures result && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, s, u, P ++ Q)
  ensures result && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P ++ Q) == ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) + ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, Q)
{
  ParallelASSSPLemmas_lemma_path_trans_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, s, t, u, P, Q) && ParallelASSSPLemmas_lemma_cost_app_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P, Q)
}

function ParallelASSSPLemmas_assertSeq_Sequence$Integer$_Boolean(xs: Seq[Int], b: Bool): Seq[Int]
  requires b
  ensures result == xs
{
  xs
}

function ParallelASSSPLemmas_lemma_expath_trans_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], s: Int, t: Int, u: Int, len1: Int, len2: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, s, t, len1)
  requires ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, t, u, len2)
  ensures result && ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, s, u, len1 + len2)
{
  (forall P: Seq[Int], Q: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, s, t, P) && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, t, u, Q) ==> ParallelASSSPLemmas_lemma_cost_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, s, t, u, P, Q))
}

function ParallelASSSPLemmas_lemma_inv12_helper1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int, vertex: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires 0 <= vertex && vertex < V
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P)
  requires |P| <= i + 1
  requires oldcost[src] == 0 && cost[src] == 0 && cost[vertex] == ParallelASSSPLemmas_inf()
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() ==> cost[end[a]] != ParallelASSSPLemmas_inf())
  ensures false
{
  vertex != src && 0 < |P| && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, start[P[|P| - 1]], P[0..][..|P| - 1 - 0])
}

function ParallelASSSPLemmas_lemma_inv12_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int, vertex: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires 0 <= vertex && vertex < V
  requires oldcost[src] == 0 && cost[src] == 0 && cost[vertex] == ParallelASSSPLemmas_inf()
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() ==> cost[end[a]] != ParallelASSSPLemmas_inf())
  ensures (forall P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1 ==> false)
{
  (forall P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1 ==> ParallelASSSPLemmas_lemma_inv12_helper1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, oldcost, cost, src, i, vertex, P))
}

function ParallelASSSPLemmas_lemma_inv12_helper3_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires oldcost[src] == 0 && cost[src] == 0
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() ==> cost[end[a]] != ParallelASSSPLemmas_inf())
  ensures (forall vertex: Int, P: Seq[Int] :: 0 <= vertex && vertex < V && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1) ==> vertex != ParallelASSSPLemmas_inf())
{
  (forall vertex: Int :: 0 <= vertex && vertex < V && cost[vertex] == ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_lemma_inv12_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, oldcost, cost, src, i, vertex))
}

function ParallelASSSPLemmas_lemma_inv11_helper1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int, vertex: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires 0 <= vertex && vertex < V
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P)
  requires |P| <= i + 1
  requires oldcost[src] == 0 && cost[src] == 0 && cost[vertex] != ParallelASSSPLemmas_inf()
  requires ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) < cost[vertex]
  requires (forall v: Int, t: Seq[Int] :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, v, t) && |t| <= i) ==> oldcost[v] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, t))
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall v: Int :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, oldcost[v]))
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() && (oldcost[end[a]] == ParallelASSSPLemmas_inf() || oldcost[start[a]] + weight[a] <= oldcost[end[a]]) ==> cost[end[a]] <= oldcost[start[a]] + weight[a])
  ensures false
{
  0 < |P| && P == P[0..][..|P| - 1 - 0] ++ Seq(P[|P| - 1]) && ParallelASSSPLemmas_lemma_cost_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, src, start[P[|P| - 1]], vertex, P[0..][..|P| - 1 - 0], Seq(P[|P| - 1]))
}

function ParallelASSSPLemmas_lemma_inv11_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int, vertex: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires 0 <= vertex && vertex < V
  requires oldcost[src] == 0 && cost[src] == 0 && cost[vertex] != ParallelASSSPLemmas_inf()
  requires (forall v: Int, t: Seq[Int] :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, v, t) && |t| <= i) ==> oldcost[v] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, t))
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall v: Int :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, oldcost[v]))
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() && (oldcost[end[a]] == ParallelASSSPLemmas_inf() || oldcost[start[a]] + weight[a] <= oldcost[end[a]]) ==> cost[end[a]] <= oldcost[start[a]] + weight[a])
  ensures (forall P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1 && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) < cost[vertex] ==> false)
{
  (forall P: Seq[Int] :: ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1 && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) < cost[vertex] ==> ParallelASSSPLemmas_lemma_inv11_helper1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, oldcost, cost, src, i, vertex, P))
}

function ParallelASSSPLemmas_lemma_inv11_helper3_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires oldcost[src] == 0 && cost[src] == 0
  requires (forall v: Int, t: Seq[Int] :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, v, t) && |t| <= i) ==> oldcost[v] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, t))
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall v: Int :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, oldcost[v]))
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() && (oldcost[end[a]] == ParallelASSSPLemmas_inf() || oldcost[start[a]] + weight[a] <= oldcost[end[a]]) ==> cost[end[a]] <= oldcost[start[a]] + weight[a])
  ensures (forall vertex: Int, P: Seq[Int] :: 0 <= vertex && vertex < V && cost[vertex] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1 && ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) < cost[vertex]) ==> vertex != ParallelASSSPLemmas_inf())
{
  (forall vertex: Int :: 0 <= vertex && vertex < V && cost[vertex] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_lemma_inv11_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, oldcost, cost, src, i, vertex))
}

function ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs: Seq[Int], elem: Int, idx: Int): Seq[Seq[Int]]
  ensures |result| == 2
  ensures |result[0]| + |result[1]| == |xs|
  ensures (forall i: Int :: 0 <= i && i < |result[0]| ==> idx <= result[0][i] && result[0][i] < |xs| + idx)
  ensures (forall i: Int :: 0 <= i && i < |result[1]| ==> idx <= result[1][i] && result[1][i] < |xs| + idx)
  ensures (forall i: Int :: 0 <= i && i < |result[0]| ==> xs[result[0][i] - idx] != elem)
  ensures (forall i: Int :: 0 <= i && i < |result[1]| ==> xs[result[1][i] - idx] == elem)
  ensures (forall i: Int, j: Int :: 0 <= i && i < |result[0]| && (i < j && j < |result[0]|) ==> result[0][i] != result[0][j])
  ensures (forall i: Int, j: Int :: 0 <= i && i < |result[1]| && (i < j && j < |result[1]|) ==> result[1][i] != result[1][j])
  ensures |result[1]| == 0 ==> (forall i: Int :: { xs[i] } 0 <= i && i < |xs| ==> xs[i] != elem)
{
  (|xs| == 0 ? Seq(Seq[Int](), Seq[Int]()) : Seq((xs[0] == elem ? Seq[Int]() : Seq(idx)) ++ ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs[1..], elem, idx + 1)[0], (xs[0] == elem ? Seq(idx) : Seq[Int]()) ++ ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs[1..], elem, idx + 1)[1]))
}

function ParallelASSSPLemmas_mapIndices_Sequence$Integer$_Sequence$Integer$(xs: Seq[Int], idx: Seq[Int]): Seq[Int]
  requires (forall i: Int :: { idx[i] } 0 <= i && i < |idx| ==> 0 <= idx[i] && idx[i] < |xs|)
  ensures |result| == |idx|
  ensures (forall i: Int :: { result[i] } 0 <= i && i < |result| ==> result[i] == xs[idx[i]])
{
  (|idx| == 0 ? Seq[Int]() : Seq(xs[idx[0]]) ++ ParallelASSSPLemmas_mapIndices_Sequence$Integer$_Sequence$Integer$(xs, idx[1..]))
}

function ParallelASSSPLemmas_simple_path_lemma1_helper_Sequence$Integer$_Integer(xs: Seq[Int], upper: Int): Bool
  requires 0 <= upper
  requires (forall i: Int :: { xs[i] } 0 <= i && i < |xs| ==> 0 <= xs[i] && xs[i] < upper)
  requires (forall i: Int, j: Int :: { xs[j],xs[i] } 0 <= i && i < |xs| && (i < j && j < |xs|) ==> xs[i] != xs[j])
  decreases _
  ensures 1 < |ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1]| ==> ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1][0] != ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1][1] && xs[ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1][0]] == xs[ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1][1]]
  ensures |ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1]| < 2
  ensures |xs| == |ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[0]| + |ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[1]|
  ensures 0 < upper ==> ParallelASSSPLemmas_simple_path_lemma1_helper_Sequence$Integer$_Integer(ParallelASSSPLemmas_mapIndices_Sequence$Integer$_Sequence$Integer$(xs, ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[0]), upper - 1)
  ensures 0 < upper ==> |ParallelASSSPLemmas_mapIndices_Sequence$Integer$_Sequence$Integer$(xs, ParallelASSSPLemmas_groupBy_Sequence$Integer$_Integer_Integer(xs, upper - 1, 0)[0])| <= upper - 1
  ensures result
{
  |xs| <= upper
}

function ParallelASSSPLemmas_vertices_in_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], P: Seq[Int], x: Int, y: Int, i: Int): Seq[Int]
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  requires i <= |P| - 1 && -1 <= i
  ensures |result| == i + 2
  ensures i == |P| - 1 ==> |result| == |P| + 1
  ensures (forall k: Int :: { result[k] } 0 <= k && k < |result| ==> 0 <= result[k] && result[k] < V)
  ensures result[0] == x
  ensures (forall k: Int :: { result[k] } 1 <= k && k < |result| ==> result[k] == end[P[k - 1]])
  ensures (forall k: Int, t: Int :: { result[t],result[k] } 0 <= k && k < |result| && (k < t && t < |result|) ==> result[k] != result[t])
{
  (i == -1 ? Seq(x) : ParallelASSSPLemmas_vertices_in_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, P, x, y, i - 1) ++ Seq(end[P[i]]))
}

function ParallelASSSPLemmas_simple_path_lemma1_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  ensures result && |P| < V
{
  ParallelASSSPLemmas_simple_path_lemma1_helper_Sequence$Integer$_Integer(ParallelASSSPLemmas_vertices_in_path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, P, x, y, |P| - 1), V)
}

function ParallelASSSPLemmas_simple_path_lemma1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall P: Seq[Int] :: ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) ==> |P| < V)
{
  (forall P: Seq[Int] :: ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) ==> ParallelASSSPLemmas_simple_path_lemma1_helper2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P))
}

function ParallelASSSPLemmas_trim_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, z: Int, P: Seq[Int], Q: Seq[Int]): Seq[Int]
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, y, z, Q)
  requires (forall i: Int, j: Int :: 0 < i && i < |P| && (0 <= j && j < |Q|) ==> start[P[i]] != end[Q[j]])
  requires (forall i: Int :: 0 <= i && i < |P| ==> end[P[i]] != x)
  ensures ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, z, result)
  ensures |result| <= |P| + |Q|
  ensures ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, result) <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P) + ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, Q)
{
  (0 < |Q| ? (end[Q[0]] == x ? ParallelASSSPLemmas_trim_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, x, x, z, Seq[Int](), Q[1..]) : ParallelASSSPLemmas_assertSeq_Sequence$Integer$_Boolean(ParallelASSSPLemmas_trim_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, x, end[Q[0]], z, P ++ Seq(Q[0]), Q[1..]), ParallelASSSPLemmas_lemma_cost_app_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P ++ Seq(Q[0]), Q[1..]) && ParallelASSSPLemmas_lemma_app_append_right_Sequence$Integer$_Sequence$Integer$(P, Q) && ParallelASSSPLemmas_lemma_cost_app_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P, Q))) : P)
}

function ParallelASSSPLemmas_extend_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, z: Int, a: Int, P: Seq[Int]): Seq[Int]
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, y, z, P)
  requires 0 <= a && a < A && start[a] == x && end[a] == y
  ensures ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, z, result)
  ensures |result| <= |P| + 1
  ensures ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, result) <= weight[a] + ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P)
{
  ParallelASSSPLemmas_trim_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, x, y, z, Seq(a), P)
}

function ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int]): Seq[Int]
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  ensures ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, result)
  ensures |result| <= |P|
  ensures ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, result) <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P)
{
  (0 < |P| ? ParallelASSSPLemmas_extend_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, end[P[0]], y, P[0], ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, end[P[0]], y, P[1..])) : P)
}

function ParallelASSSPLemmas_simple_path_Part_1_lemma2_helper_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int, P: Seq[Int]): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
  ensures result && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P)
{
  true
}

function ParallelASSSPLemmas_simple_path_Part_1_lemma2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int, y: Int): Bool
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall P: Seq[Int] :: ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P))
{
  (forall P: Seq[Int] :: ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P) ==> ParallelASSSPLemmas_simple_path_Part_1_lemma2_helper_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, y, P))
}

function instanceof_TYPE_TYPE(t: TYPE, u: TYPE): Bool
  ensures result == (t == u || directSuperclass(t) == u)


method ParallelASSSPLemmas___contract_unsatisfiable__lemma_one_path_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int])
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_lemma_one_path_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int])
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall i: Int :: 0 <= i && i < A ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, start[i], end[i], Seq(i)))
  ensures (forall i: Int :: 0 <= i && i < A ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, start[i], end[i], weight[i]))
{
  // assert
  assert (forall i__1: Int :: 0 <= i__1 && i__1 < A ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, start[i__1], end[i__1], Seq(i__1)))
  // assert
  assert (forall i__2: Int :: 0 <= i__2 && i__2 < A ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, start[i__2], end[i__2], weight[i__2]))
}

method ParallelASSSPLemmas___contract_unsatisfiable__lemma_inv12_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int)
  requires diz != null
{
  inhale true && (ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight) && (|oldcost| == V && |cost| == V) && (forall k__3: Int :: { oldcost[k__3] } { cost[k__3] } 0 <= k__3 && k__3 < V && cost[k__3] == ParallelASSSPLemmas_inf() ==> oldcost[k__3] == cost[k__3]) && (forall k__4: Int :: { oldcost[k__4] } { cost[k__4] } 0 <= k__4 && k__4 < V && oldcost[k__4] == ParallelASSSPLemmas_inf() ==> oldcost[k__4] <= cost[k__4]) && (forall k__5: Int :: { cost[k__5] } { oldcost[k__5] } 0 <= k__5 && k__5 < V && oldcost[k__5] != ParallelASSSPLemmas_inf() ==> cost[k__5] <= oldcost[k__5]) && (forall k__6: Int :: { cost[k__6] } 0 <= k__6 && k__6 < V && k__6 != src ==> cost[k__6] == ParallelASSSPLemmas_inf() || 0 < cost[k__6]) && (0 <= i && i < V - 1) && (0 <= src && src < V) && (oldcost[src] == 0 && cost[src] == 0) && (forall v__7: Int :: 0 <= v__7 && v__7 < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v__7, i) ==> oldcost[v__7] != ParallelASSSPLemmas_inf()) && (forall a__8: Int :: 0 <= a__8 && a__8 < A && oldcost[start[a__8]] != ParallelASSSPLemmas_inf() ==> cost[end[a__8]] != ParallelASSSPLemmas_inf()))
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_lemma_inv12_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires oldcost[src] == 0 && cost[src] == 0
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() ==> cost[end[a]] != ParallelASSSPLemmas_inf())
  ensures (forall v: Int :: { cost[v] } 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i + 1) ==> cost[v] != ParallelASSSPLemmas_inf())
{
  // assert
  assert ParallelASSSPLemmas_lemma_inv12_helper3_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V, A, start, end, weight, oldcost, cost, src, i)
}

method ParallelASSSPLemmas___contract_unsatisfiable__lemma_inv11_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int)
  requires diz != null
{
  inhale true && (ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight) && (|oldcost| == V && |cost| == V) && (forall k__9: Int :: { oldcost[k__9] } { cost[k__9] } 0 <= k__9 && k__9 < V && cost[k__9] == ParallelASSSPLemmas_inf() ==> oldcost[k__9] == cost[k__9]) && (forall k__10: Int :: { oldcost[k__10] } { cost[k__10] } 0 <= k__10 && k__10 < V && oldcost[k__10] == ParallelASSSPLemmas_inf() ==> oldcost[k__10] <= cost[k__10]) && (forall k__11: Int :: { cost[k__11] } { oldcost[k__11] } 0 <= k__11 && k__11 < V && oldcost[k__11] != ParallelASSSPLemmas_inf() ==> cost[k__11] <= oldcost[k__11]) && (forall k__12: Int :: { cost[k__12] } 0 <= k__12 && k__12 < V && k__12 != src ==> cost[k__12] == ParallelASSSPLemmas_inf() || 0 < cost[k__12]) && (0 <= i && i < V - 1) && (0 <= src && src < V) && (oldcost[src] == 0 && cost[src] == 0) && (forall v__13: Int, t__14: Seq[Int] :: 0 <= v__13 && v__13 < V && oldcost[v__13] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, v__13, t__14) && |t__14| <= i) ==> oldcost[v__13] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, t__14)) && (forall v__15: Int :: 0 <= v__15 && v__15 < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v__15, i) ==> oldcost[v__15] != ParallelASSSPLemmas_inf()) && (forall v__16: Int :: 0 <= v__16 && v__16 < V && oldcost[v__16] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v__16, oldcost[v__16])) && (forall a__17: Int :: 0 <= a__17 && a__17 < A && oldcost[start[a__17]] != ParallelASSSPLemmas_inf() && (oldcost[end[a__17]] == ParallelASSSPLemmas_inf() || oldcost[start[a__17]] + weight[a__17] <= oldcost[end[a__17]]) ==> cost[end[a__17]] <= oldcost[start[a__17]] + weight[a__17]))
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_lemma_inv11_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], oldcost: Seq[Int], cost: Seq[Int], src: Int, i: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  requires |oldcost| == V && |cost| == V
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && cost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] == cost[k])
  requires (forall k: Int :: { oldcost[k] } { cost[k] } 0 <= k && k < V && oldcost[k] == ParallelASSSPLemmas_inf() ==> oldcost[k] <= cost[k])
  requires (forall k: Int :: { cost[k] } { oldcost[k] } 0 <= k && k < V && oldcost[k] != ParallelASSSPLemmas_inf() ==> cost[k] <= oldcost[k])
  requires (forall k: Int :: { cost[k] } 0 <= k && k < V && k != src ==> cost[k] == ParallelASSSPLemmas_inf() || 0 < cost[k])
  requires 0 <= i && i < V - 1
  requires 0 <= src && src < V
  requires oldcost[src] == 0 && cost[src] == 0
  requires (forall v: Int, t: Seq[Int] :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, v, t) && |t| <= i) ==> oldcost[v] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, t))
  requires (forall v: Int :: 0 <= v && v < V && ParallelASSSPLemmas_ExPath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, i) ==> oldcost[v] != ParallelASSSPLemmas_inf())
  requires (forall v: Int :: 0 <= v && v < V && oldcost[v] != ParallelASSSPLemmas_inf() ==> ParallelASSSPLemmas_ExPathEqual_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Integer(V, A, start, end, weight, src, v, oldcost[v]))
  requires (forall a: Int :: 0 <= a && a < A && oldcost[start[a]] != ParallelASSSPLemmas_inf() && (oldcost[end[a]] == ParallelASSSPLemmas_inf() || oldcost[start[a]] + weight[a] <= oldcost[end[a]]) ==> cost[end[a]] <= oldcost[start[a]] + weight[a])
  ensures (forall vertex: Int, P: Seq[Int] :: 0 <= vertex && vertex < V && cost[vertex] != ParallelASSSPLemmas_inf() && (ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, src, vertex, P) && |P| <= i + 1) ==> cost[vertex] <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P))
{
  // assert
  assert ParallelASSSPLemmas_lemma_inv11_helper3_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V, A, start, end, weight, oldcost, cost, src, i)
}

method ParallelASSSPLemmas___contract_unsatisfiable__simple_path_lemma1_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_simple_path_lemma1_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> |P| < V)
{
  // assert
  assert (forall v__18: Int, P__19: Seq[Int] :: 0 <= v__18 && v__18 < V && ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v__18, P__19) ==> ParallelASSSPLemmas_simple_path_lemma1_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V, A, start, end, weight, x, v__18))
}

method ParallelASSSPLemmas___contract_unsatisfiable__simple_path_Part_1_lemma2_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_simple_path_Part_1_lemma2_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P))
{
  // assert
  assert (forall v__20: Int :: { ParallelASSSPLemmas_simple_path_Part_1_lemma2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V, A, start, end, weight, x, v__20) } 0 <= v__20 && v__20 < V ==> ParallelASSSPLemmas_simple_path_Part_1_lemma2_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer(V, A, start, end, weight, x, v__20))
}

method ParallelASSSPLemmas___contract_unsatisfiable__simple_path_Part_2_lemma2_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_simple_path_Part_2_lemma2_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P)))
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> ParallelASSSPLemmas_SimplePath_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P)))
{
  
}

method ParallelASSSPLemmas___contract_unsatisfiable__simple_path_lemma3_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_simple_path_lemma3_preserved_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> |ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P)| <= |P|)
{
  
}

method ParallelASSSPLemmas___contract_unsatisfiable__simple_path_cost_lemma4_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
{
  inhale true && ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  // assert
  assert false
  inhale false
}

method ParallelASSSPLemmas_simple_path_cost_lemma4_EncodedGlobalVariables_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer(diz: Ref, globals: Ref, V: Int, A: Int, start: Seq[Int], end: Seq[Int], weight: Seq[Int], x: Int)
  requires diz != null
  requires ParallelASSSPLemmas_Graph_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight)
  ensures (forall v: Int, P: Seq[Int] :: 0 <= v && v < V && ParallelASSSPLemmas_Path_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P) ==> ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, ParallelASSSPLemmas_convert_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Integer_Integer_Sequence$Integer$(V, A, start, end, weight, x, v, P)) <= ParallelASSSPLemmas_cost_Integer_Integer_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$_Sequence$Integer$(V, A, start, end, weight, P))
{
  
}
