domain Address  {
  
  function field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(_0: Address): Address 
  
  function field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(_0: Address): Address 
  
  function variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(_0: Address): Address 
  
  function variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(_0: Address): Address 
  
  function field_address$$struct$m_LinkedList$$$f$val(_0: Address): Address 
  
  function field_address$$struct$m_LinkedList$$$f$next(_0: Address): Address 
}

domain Bytes  {
  
  
}

domain Lifetime  {
  
  function included(_0: Lifetime, _1: Lifetime): Bool 
  
  function intersect(_0: Set[Lifetime]): Lifetime 
  
  axiom included_in_itself$ {
    (forall lft: Lifetime :: { included(lft, lft) } included(lft, lft))
  }
  
  axiom included_intersect$1 {
    (forall lft_1: Set[Lifetime], lft_2: Set[Lifetime] ::
      { included(intersect(lft_1), intersect(lft_2)) }
      included(intersect(lft_1), intersect(lft_2)) == (lft_2 subset lft_1))
  }
  
  axiom included_intersect$2 {
    (forall lft_1: Set[Lifetime], lft_2: Lifetime ::
      { included(intersect(lft_1), lft_2) }
      included(intersect(lft_1), lft_2) == (lft_2 in lft_1))
  }
  
  axiom intersect_singleton$ {
    (forall lft: Lifetime ::
      { intersect(Set(lft)) }
      intersect(Set(lft)) == lft)
  }
}

domain MarkerCalls  {
  
  function basic_block_marker$start_label$marker(): Bool 
  
  function basic_block_marker$label_entry$marker(): Bool 
  
  function basic_block_marker$label_bb0$marker(): Bool 
  
  function basic_block_marker$label_3_custom$marker(): Bool 
  
  function basic_block_marker$label_2_custom$marker(): Bool 
  
  function basic_block_marker$label_bb1$marker(): Bool 
  
  function basic_block_marker$label_6_custom$marker(): Bool 
  
  function basic_block_marker$label_bb10$marker(): Bool 
  
  function basic_block_marker$label_bb11$marker(): Bool 
  
  function basic_block_marker$label_bb14$marker(): Bool 
  
  function basic_block_marker$label_8_custom$marker(): Bool 
  
  function basic_block_marker$label_bb13$marker(): Bool 
  
  function basic_block_marker$label_9_custom$marker(): Bool 
  
  function basic_block_marker$label_7_custom$marker(): Bool 
  
  function basic_block_marker$label_bb12$marker(): Bool 
  
  function basic_block_marker$resume_panic_label$marker(): Bool 
  
  function basic_block_marker$label_5_custom$marker(): Bool 
  
  function basic_block_marker$label_bb2$marker(): Bool 
  
  function basic_block_marker$label_bb4$marker(): Bool 
  
  function basic_block_marker$label_bb5$marker(): Bool 
  
  function basic_block_marker$label_bb6$marker(): Bool 
  
  function basic_block_marker$label_bb7$marker(): Bool 
  
  function basic_block_marker$label_bb8$marker(): Bool 
  
  function basic_block_marker$label_bb9$marker(): Bool 
  
  function basic_block_marker$return_label$marker(): Bool 
  
  function basic_block_marker$end_label$marker(): Bool 
}

domain Place  {
  
  unique function _1$place(): Place 
  
  unique function _2$place(): Place 
  
  unique function _15$place(): Place 
  
  function deref_reference_place(_0: Place): Place 
  
  unique function _4$place(): Place 
  
  unique function _3$place(): Place 
  
  function field_place$$struct$m_LinkedList$$$f$val(_0: Place): Place 
  
  function field_place$$struct$m_LinkedList$$$f$next(_0: Place): Place 
  
  function field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(_0: Place): Place 
  
  function variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(_0: Place): Place 
  
  function variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(_0: Place): Place 
  
  function field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(_0: Place): Place 
  
  unique function _6$place(): Place 
  
  unique function _5$place(): Place 
  
  unique function _8$place(): Place 
  
  unique function _7$place(): Place 
  
  unique function _12$place(): Place 
  
  unique function _14$place(): Place 
  
  unique function _13$place(): Place 
  
  unique function _0$place(): Place 
}

domain Size  {
  
  function Size$struct$m_LinkedList$$(): Snap$Usize 
  
  function Size$Bool$(): Snap$Usize 
  
  function Size$Unbounded$(): Snap$Usize 
  
  function Size$ref$Shared$struct$m_LinkedList$$(): Snap$Usize 
  
  function Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$(): Snap$Usize 
  
  function Size$I64$(): Snap$Usize 
  
  function Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function Size$Isize$(): Snap$Usize 
  
  function Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$Usize 
  
  function PaddingSize$struct$m_LinkedList$$(): Snap$Usize 
  
  function Size$Tuple$$$$(): Snap$Usize 
  
  function PaddingSize$Tuple$$$$(): Snap$Usize 
}

domain Snap$Bool  {
  
  function constructor$Snap$Bool$(value: Bool): Snap$Bool 
  
  function destructor$Snap$Bool$$value(value: Snap$Bool): Bool 
  
  function valid$Snap$Bool(_0: Snap$Bool): Bool 
  
  function to_bytes$Bool(snapshot: Snap$Bool): Bytes 
  
  axiom constructor$Snap$Bool$$bottom_up_injectivity_axiom {
    (forall value: Bool ::
      { constructor$Snap$Bool$(value) }
      destructor$Snap$Bool$$value(constructor$Snap$Bool$(value)) == value)
  }
  
  axiom constructor$Snap$Bool$$top_down_injectivity_axiom {
    (forall value: Snap$Bool ::
      { valid$Snap$Bool(value) }
      valid$Snap$Bool(value) ==>
      value == constructor$Snap$Bool$(destructor$Snap$Bool$$value(value)))
  }
  
  axiom Snap$Bool$$validity_axiom_bottom_up_alternative {
    (forall value: Bool ::
      { valid$Snap$Bool(constructor$Snap$Bool$(value)) }
      valid$Snap$Bool(constructor$Snap$Bool$(value)))
  }
}

domain Snap$I64  {
  
  function constructor$Snap$I64$(value: Int): Snap$I64 
  
  function destructor$Snap$I64$$value(value: Snap$I64): Int 
  
  function valid$Snap$I64(_0: Snap$I64): Bool 
  
  function to_bytes$I64(snapshot: Snap$I64): Bytes 
  
  axiom constructor$Snap$I64$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$I64$(value) }
      destructor$Snap$I64$$value(constructor$Snap$I64$(value)) == value)
  }
  
  axiom constructor$Snap$I64$$top_down_injectivity_axiom {
    (forall value: Snap$I64 ::
      { valid$Snap$I64(value) }
      valid$Snap$I64(value) ==>
      value == constructor$Snap$I64$(destructor$Snap$I64$$value(value)))
  }
  
  axiom Snap$I64$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$I64(constructor$Snap$I64$(value)) }
      valid$Snap$I64(constructor$Snap$I64$(value)) ==
      (-9223372036854775808 <= value && value <= 9223372036854775807))
  }
}

domain Snap$Isize  {
  
  function constructor$Snap$Isize$(value: Int): Snap$Isize 
  
  function destructor$Snap$Isize$$value(value: Snap$Isize): Int 
  
  function valid$Snap$Isize(_0: Snap$Isize): Bool 
  
  function to_bytes$Isize(snapshot: Snap$Isize): Bytes 
  
  axiom constructor$Snap$Isize$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Isize$(value) }
      destructor$Snap$Isize$$value(constructor$Snap$Isize$(value)) == value)
  }
  
  axiom constructor$Snap$Isize$$top_down_injectivity_axiom {
    (forall value: Snap$Isize ::
      { valid$Snap$Isize(value) }
      valid$Snap$Isize(value) ==>
      value == constructor$Snap$Isize$(destructor$Snap$Isize$$value(value)))
  }
  
  axiom Snap$Isize$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Isize(constructor$Snap$Isize$(value)) }
      valid$Snap$Isize(constructor$Snap$Isize$(value)) ==
      (-9223372036854775808 <= value && value <= 9223372036854775807))
  }
}

domain Snap$Tuple$$$  {
  
  function constructor$Snap$Tuple$$$$(): Snap$Tuple$$$ 
  
  function valid$Snap$Tuple$$$(_0: Snap$Tuple$$$): Bool 
  
  function to_bytes$Tuple$$$(snapshot: Snap$Tuple$$$): Bytes 
  
  axiom Snap$Tuple$$$$validity_axiom_bottom_up_alternative_no_parameters {
    valid$Snap$Tuple$$$(constructor$Snap$Tuple$$$$())
  }
}

domain Snap$Unbounded  {
  
  function constructor$Snap$Unbounded$(value: Int): Snap$Unbounded 
  
  function destructor$Snap$Unbounded$$value(value: Snap$Unbounded): Int 
  
  function valid$Snap$Unbounded(_0: Snap$Unbounded): Bool 
  
  function to_bytes$Unbounded(snapshot: Snap$Unbounded): Bytes 
  
  axiom constructor$Snap$Unbounded$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Unbounded$(value) }
      destructor$Snap$Unbounded$$value(constructor$Snap$Unbounded$(value)) ==
      value)
  }
  
  axiom constructor$Snap$Unbounded$$top_down_injectivity_axiom {
    (forall value: Snap$Unbounded ::
      { valid$Snap$Unbounded(value) }
      valid$Snap$Unbounded(value) ==>
      value ==
      constructor$Snap$Unbounded$(destructor$Snap$Unbounded$$value(value)))
  }
  
  axiom Snap$Unbounded$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Unbounded(constructor$Snap$Unbounded$(value)) }
      valid$Snap$Unbounded(constructor$Snap$Unbounded$(value)))
  }
}

domain Snap$Usize  {
  
  function constructor$Snap$Usize$(value: Int): Snap$Usize 
  
  function destructor$Snap$Usize$$value(value: Snap$Usize): Int 
  
  function valid$Snap$Usize(_0: Snap$Usize): Bool 
  
  axiom constructor$Snap$Usize$$bottom_up_injectivity_axiom {
    (forall value: Int ::
      { constructor$Snap$Usize$(value) }
      destructor$Snap$Usize$$value(constructor$Snap$Usize$(value)) == value)
  }
  
  axiom constructor$Snap$Usize$$top_down_injectivity_axiom {
    (forall value: Snap$Usize ::
      { valid$Snap$Usize(value) }
      valid$Snap$Usize(value) ==>
      value == constructor$Snap$Usize$(destructor$Snap$Usize$$value(value)))
  }
  
  axiom Snap$Usize$$validity_axiom_bottom_up_alternative {
    (forall value: Int ::
      { valid$Snap$Usize(constructor$Snap$Usize$(value)) }
      valid$Snap$Usize(constructor$Snap$Usize$(value)) ==
      (0 <= value && value <= 18446744073709551615))
  }
}

domain Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(): Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function to_bytes$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_bottom_up_alternative_no_parameters {
    valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$())
  }
}

domain Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$bottom_up_injectivity_axiom {
    (forall f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0) }
      destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)) ==
      f$0)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(value)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$validity_axiom_bottom_up_alternative {
    (forall f$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)),
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(f$0) }
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(f$0)) ==
      valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(f$0))
  }
}

domain Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$  {
  
  function constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bool 
  
  function discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(_0: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Int 
  
  function to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Bytes 
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$bottom_up_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value) }
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(value)) ==
      value)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==
      0 ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(value)))
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$bottom_up_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value) }
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(value)) ==
      value)
  }
  
  axiom constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$top_down_injectivity_axiom {
    (forall value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(value) ==
      1 ==>
      value ==
      constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(value)))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$validity_axiom_top_down_enum {
    (forall snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot) }
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot) }
      { valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot),
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      (0 <=
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) &&
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) <=
      1 &&
      ((discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      0 ==>
      valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot))) &&
      (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
      1 ==>
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot))))))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$validity_axiom_bottom_up_enum_variant {
    (forall variant: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant),
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) ==
      valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$discriminant_axiom {
    (forall variant: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant) }
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None(variant)) ==
      0)
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$validity_axiom_bottom_up_enum_variant {
    (forall variant: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant),
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) }
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) ==
      valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant))
  }
  
  axiom Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$discriminant_axiom {
    (forall variant: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant) }
      discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(variant)) ==
      1)
  }
}

domain Snap$ptr$struct$m_LinkedList$  {
  
  function to_bytes$ptr$struct$m_LinkedList$(snapshot: Snap$ptr$struct$m_LinkedList$): Bytes 
  
  function constructor$Snap$ptr$struct$m_LinkedList$$(value: Address): Snap$ptr$struct$m_LinkedList$ 
  
  function destructor$Snap$ptr$struct$m_LinkedList$$$value(value: Snap$ptr$struct$m_LinkedList$): Address 
  
  function valid$Snap$ptr$struct$m_LinkedList$(_0: Snap$ptr$struct$m_LinkedList$): Bool 
  
  axiom constructor$Snap$ptr$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall value: Address ::
      { constructor$Snap$ptr$struct$m_LinkedList$$(value) }
      destructor$Snap$ptr$struct$m_LinkedList$$$value(constructor$Snap$ptr$struct$m_LinkedList$$(value)) ==
      value)
  }
  
  axiom constructor$Snap$ptr$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$ptr$struct$m_LinkedList$ ::
      { valid$Snap$ptr$struct$m_LinkedList$(value) }
      valid$Snap$ptr$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ptr$struct$m_LinkedList$$(destructor$Snap$ptr$struct$m_LinkedList$$$value(value)))
  }
  
  axiom Snap$ptr$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall value: Address ::
      { valid$Snap$ptr$struct$m_LinkedList$(constructor$Snap$ptr$struct$m_LinkedList$$(value)) }
      valid$Snap$ptr$struct$m_LinkedList$(constructor$Snap$ptr$struct$m_LinkedList$$(value)))
  }
}

domain Snap$ref$Shared$struct$m_LinkedList$  {
  
  function constructor$Snap$ref$Shared$struct$m_LinkedList$$(address: Address,
  target_current: Snap$struct$m_LinkedList$): Snap$ref$Shared$struct$m_LinkedList$ 
  
  function destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value: Snap$ref$Shared$struct$m_LinkedList$): Address 
  
  function destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value: Snap$ref$Shared$struct$m_LinkedList$): Snap$struct$m_LinkedList$ 
  
  function valid$Snap$ref$Shared$struct$m_LinkedList$(_0: Snap$ref$Shared$struct$m_LinkedList$): Bool 
  
  function constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current: Snap$struct$m_LinkedList$): Snap$ref$Shared$struct$m_LinkedList$ 
  
  function to_bytes$ref$Shared$struct$m_LinkedList$(snapshot: Snap$ref$Shared$struct$m_LinkedList$): Bytes 
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall address: Address, target_current: Snap$struct$m_LinkedList$ ::
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$(address, target_current) }
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$(address, target_current) }
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      address &&
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value) }
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ref$Shared$struct$m_LinkedList$$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(value),
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot) ==
      valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall address: Address, target_current: Snap$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)), valid$Snap$struct$m_LinkedList$(target_current) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$(address,
      target_current)) ==
      valid$Snap$struct$m_LinkedList$(target_current))
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc$bottom_up_injectivity_axiom {
    (forall target_current: Snap$struct$m_LinkedList$ ::
      { constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current) }
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)) ==
      target_current)
  }
  
  axiom constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc$top_down_injectivity_axiom {
    (forall value: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(value) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(value)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$no_alloc$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot), destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot) ==
      valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot)))
  }
  
  axiom Snap$ref$Shared$struct$m_LinkedList$$no_alloc$validity_axiom_bottom_up_alternative {
    (forall target_current: Snap$struct$m_LinkedList$ ::
      { valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)),
      valid$Snap$struct$m_LinkedList$(target_current) }
      valid$Snap$ref$Shared$struct$m_LinkedList$(constructor$Snap$ref$Shared$struct$m_LinkedList$$no_alloc(target_current)) ==
      valid$Snap$struct$m_LinkedList$(target_current))
  }
}

domain Snap$struct$m_LinkedList$  {
  
  function constructor$Snap$struct$m_LinkedList$$(f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$): Snap$struct$m_LinkedList$ 
  
  function destructor$Snap$struct$m_LinkedList$$$f$val(value: Snap$struct$m_LinkedList$): Snap$I64 
  
  function destructor$Snap$struct$m_LinkedList$$$f$next(value: Snap$struct$m_LinkedList$): Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ 
  
  function valid$Snap$struct$m_LinkedList$(_0: Snap$struct$m_LinkedList$): Bool 
  
  function to_bytes$struct$m_LinkedList$(snapshot: Snap$struct$m_LinkedList$): Bytes 
  
  axiom constructor$Snap$struct$m_LinkedList$$$bottom_up_injectivity_axiom {
    (forall f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { constructor$Snap$struct$m_LinkedList$$(f$val, f$next) }
      { constructor$Snap$struct$m_LinkedList$$(f$val, f$next) }
      destructor$Snap$struct$m_LinkedList$$$f$val(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      f$val &&
      destructor$Snap$struct$m_LinkedList$$$f$next(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      f$next)
  }
  
  axiom constructor$Snap$struct$m_LinkedList$$$top_down_injectivity_axiom {
    (forall value: Snap$struct$m_LinkedList$ ::
      { valid$Snap$struct$m_LinkedList$(value), destructor$Snap$struct$m_LinkedList$$$f$val(value) }
      { valid$Snap$struct$m_LinkedList$(value), destructor$Snap$struct$m_LinkedList$$$f$next(value) }
      valid$Snap$struct$m_LinkedList$(value) ==>
      value ==
      constructor$Snap$struct$m_LinkedList$$(destructor$Snap$struct$m_LinkedList$$$f$val(value),
      destructor$Snap$struct$m_LinkedList$$$f$next(value)))
  }
  
  axiom Snap$struct$m_LinkedList$$$validity_axiom_top_down_alternative {
    (forall snapshot: Snap$struct$m_LinkedList$ ::
      { valid$Snap$struct$m_LinkedList$(snapshot), destructor$Snap$struct$m_LinkedList$$$f$val(snapshot) }
      { valid$Snap$struct$m_LinkedList$(snapshot), destructor$Snap$struct$m_LinkedList$$$f$next(snapshot) }
      valid$Snap$struct$m_LinkedList$(snapshot) ==
      (valid$Snap$I64(destructor$Snap$struct$m_LinkedList$$$f$val(snapshot)) &&
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$struct$m_LinkedList$$$f$next(snapshot))))
  }
  
  axiom Snap$struct$m_LinkedList$$$validity_axiom_bottom_up_alternative {
    (forall f$val: Snap$I64, f$next: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { valid$Snap$struct$m_LinkedList$(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)), valid$Snap$I64(f$val), valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(f$next) }
      valid$Snap$struct$m_LinkedList$(constructor$Snap$struct$m_LinkedList$$(f$val,
      f$next)) ==
      (valid$Snap$I64(f$val) &&
      valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(f$next)))
  }
}

domain Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$  {
  
  function valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(_0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bool 
  
  function to_bytes$trusted$m_BoxWrapper$struct$m_LinkedList$$(snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$): Bytes 
}

domain ComputeAddress  {
  
  function compute_address(place: Place, address: Address): Address 
  
  axiom root$1$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_1$place(), address) }
      compute_address(_1$place(), address) == address)
  }
  
  axiom root$2$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_2$place(), address) }
      compute_address(_2$place(), address) == address)
  }
  
  axiom root$3$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_15$place(), address) }
      compute_address(_15$place(), address) == address)
  }
  
  axiom ref$Shared$struct$m_LinkedList$$compute_address_axiom {
    (forall place: Place, snapshot: Snap$ref$Shared$struct$m_LinkedList$ ::
      { compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot)) }
      compute_address(deref_reference_place(place), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot)) ==
      destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot))
  }
  
  axiom root$4$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_4$place(), address) }
      compute_address(_4$place(), address) == address)
  }
  
  axiom root$5$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_3$place(), address) }
      compute_address(_3$place(), address) == address)
  }
  
  axiom struct$m_LinkedList$$f$val$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$struct$m_LinkedList$$$f$val(place), address) }
      compute_address(field_place$$struct$m_LinkedList$$$f$val(place), address) ==
      field_address$$struct$m_LinkedList$$$f$val(compute_address(place, address)))
  }
  
  axiom struct$m_LinkedList$$f$next$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$struct$m_LinkedList$$$f$next(place), address) }
      compute_address(field_place$$struct$m_LinkedList$$$f$next(place), address) ==
      field_address$$struct$m_LinkedList$$$f$next(compute_address(place, address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$discriminant$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
      address) }
      compute_address(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
      address) ==
      field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
      address) }
      compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
      address) ==
      variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
      address) }
      compute_address(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
      address) ==
      variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(compute_address(place,
      address)))
  }
  
  axiom enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$f$0$compute_address_axiom {
    (forall place: Place, address: Address ::
      { compute_address(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
      address) }
      compute_address(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
      address) ==
      field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(compute_address(place,
      address)))
  }
  
  axiom root$6$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_6$place(), address) }
      compute_address(_6$place(), address) == address)
  }
  
  axiom root$7$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_5$place(), address) }
      compute_address(_5$place(), address) == address)
  }
  
  axiom root$8$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_8$place(), address) }
      compute_address(_8$place(), address) == address)
  }
  
  axiom root$9$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_7$place(), address) }
      compute_address(_7$place(), address) == address)
  }
  
  axiom root$10$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_12$place(), address) }
      compute_address(_12$place(), address) == address)
  }
  
  axiom root$11$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_14$place(), address) }
      compute_address(_14$place(), address) == address)
  }
  
  axiom root$12$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_13$place(), address) }
      compute_address(_13$place(), address) == address)
  }
  
  axiom root$13$compute_address_axiom {
    (forall address: Address ::
      { compute_address(_0$place(), address) }
      compute_address(_0$place(), address) == address)
  }
}

function MemoryBlock$bytes(address: Address, size: Snap$Usize): Bytes
  requires acc(MemoryBlock(address, size), wildcard)


predicate OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$) {
  valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write) &&
  acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
  root_address, destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot)), write)
}

predicate OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(place: Place,
  root_address: Address, snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$) 

predicate OwnedNonAliased$Unbounded(place: Place, root_address: Address, snapshot: Snap$Unbounded) {
  valid$Snap$Unbounded(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), Size$Unbounded$()), write) &&
  MemoryBlock$bytes(compute_address(place, root_address), Size$Unbounded$()) ==
  to_bytes$Unbounded(snapshot)
}

predicate OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$) {
  valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write) &&
  acc(OwnedNonAliased$Isize(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
  root_address, constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))), write) &&
  (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
  0 ?
    acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
    root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot)), write) :
    discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
    1 &&
    acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
    root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot)), write))
}

predicate OwnedNonAliased$I64(place: Place, root_address: Address, snapshot: Snap$I64) {
  valid$Snap$I64(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), Size$I64$()), write) &&
  MemoryBlock$bytes(compute_address(place, root_address), Size$I64$()) ==
  to_bytes$I64(snapshot)
}

predicate OwnedNonAliased$Tuple$$$(place: Place, root_address: Address, snapshot: Snap$Tuple$$$) {
  valid$Snap$Tuple$$$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), PaddingSize$Tuple$$$$()), write)
}

predicate OwnedNonAliased$struct$m_LinkedList$(place: Place, root_address: Address,
  snapshot: Snap$struct$m_LinkedList$) {
  valid$Snap$struct$m_LinkedList$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), PaddingSize$struct$m_LinkedList$$()), write) &&
  acc(OwnedNonAliased$I64(field_place$$struct$m_LinkedList$$$f$val(place), root_address,
  destructor$Snap$struct$m_LinkedList$$$f$val(snapshot)), write) &&
  acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(field_place$$struct$m_LinkedList$$$f$next(place),
  root_address, destructor$Snap$struct$m_LinkedList$$$f$next(snapshot)), write)
}

predicate OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$) {
  valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
}

predicate OwnedNonAliased$Isize(place: Place, root_address: Address, snapshot: Snap$Isize) {
  valid$Snap$Isize(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), Size$Isize$()), write) &&
  MemoryBlock$bytes(compute_address(place, root_address), Size$Isize$()) ==
  to_bytes$Isize(snapshot)
}

predicate OwnedNonAliased$ref$Shared$struct$m_LinkedList$(place: Place, root_address: Address,
  snapshot: Snap$ref$Shared$struct$m_LinkedList$, lft_erased$alive: Bool, lft_erased: Lifetime) {
  valid$Snap$ref$Shared$struct$m_LinkedList$(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), Size$ref$Shared$struct$m_LinkedList$$()), write) &&
  MemoryBlock$bytes(compute_address(place, root_address), Size$ref$Shared$struct$m_LinkedList$$()) ==
  to_bytes$ptr$struct$m_LinkedList$(constructor$Snap$ptr$struct$m_LinkedList$$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot))) &&
  acc(FracRef2$struct$m_LinkedList$(deref_reference_place(place), destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(snapshot),
  destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(snapshot),
  lft_erased), write)
}

predicate FracRef2$struct$m_LinkedList$(place: Place, root_address: Address,
  current_snapshot: Snap$struct$m_LinkedList$, reference_lifetime: Lifetime) {
  valid$Snap$struct$m_LinkedList$(current_snapshot) &&
  acc(FracRef2$I64(field_place$$struct$m_LinkedList$$$f$val(place), root_address,
  destructor$Snap$struct$m_LinkedList$$$f$val(current_snapshot), reference_lifetime), write) &&
  acc(FracRef2$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(field_place$$struct$m_LinkedList$$$f$next(place),
  root_address, destructor$Snap$struct$m_LinkedList$$$f$next(current_snapshot),
  reference_lifetime), write)
}

predicate FracRef2$I64(place: Place, root_address: Address, current_snapshot: Snap$I64,
  reference_lifetime: Lifetime) 

predicate FracRef2$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, current_snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$,
  reference_lifetime: Lifetime) {
  valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot) &&
  acc(FracRef2$Isize(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
  root_address, constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot)),
  reference_lifetime), write) &&
  (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot) ==
  0 ?
    acc(FracRef2$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
    root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(current_snapshot),
    reference_lifetime), write) :
    discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot) ==
    1 &&
    acc(FracRef2$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
    root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(current_snapshot),
    reference_lifetime), write))
}

predicate FracRef2$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, current_snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$,
  reference_lifetime: Lifetime) {
  valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot)
}

predicate FracRef2$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, current_snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$,
  reference_lifetime: Lifetime) {
  valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(current_snapshot) &&
  acc(FracRef2$trusted$m_BoxWrapper$struct$m_LinkedList$$(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
  root_address, destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(current_snapshot),
  reference_lifetime), write)
}

predicate FracRef2$trusted$m_BoxWrapper$struct$m_LinkedList$$(place: Place,
  root_address: Address, current_snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$,
  reference_lifetime: Lifetime) 

predicate FracRef2$Isize(place: Place, root_address: Address, current_snapshot: Snap$Isize,
  reference_lifetime: Lifetime) 

predicate OwnedNonAliased$Bool(place: Place, root_address: Address, snapshot: Snap$Bool) {
  valid$Snap$Bool(snapshot) &&
  acc(MemoryBlock(compute_address(place, root_address), Size$Bool$()), write) &&
  MemoryBlock$bytes(compute_address(place, root_address), Size$Bool$()) ==
  to_bytes$Bool(snapshot)
}

predicate DeadLifetimeToken(lifetime: Lifetime) 

predicate LifetimeToken(lifetime: Lifetime) 

predicate MemoryBlock(address: Address, size: Snap$Usize) 

predicate MemoryBlockStackDrop(address: Address, size: Snap$Usize) 

method m_LinkedList$$prepend$CoreProof()
{
  var _0$address: Address
  var _0$snapshot$0: Snap$struct$m_LinkedList$
  var _0$snapshot$1: Snap$struct$m_LinkedList$
  var _0$snapshot$2: Snap$struct$m_LinkedList$
  var _1$address: Address
  var _1$snapshot$0: Snap$struct$m_LinkedList$
  var _1$snapshot$1: Snap$struct$m_LinkedList$
  var _12$address: Address
  var _12$snapshot$0: Snap$I64
  var _12$snapshot$1: Snap$I64
  var _12$snapshot$2: Snap$I64
  var _13$address: Address
  var _13$snapshot$0: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _13$snapshot$1: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _13$snapshot$2: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var _14$address: Address
  var _14$snapshot$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _14$snapshot$1: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _14$snapshot$2: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _15$address: Address
  var _15$snapshot$0: Snap$Bool
  var _15$snapshot$1: Snap$Bool
  var _15$snapshot$2: Snap$Bool
  var _15$snapshot$3: Snap$Bool
  var _15$snapshot$4: Snap$Bool
  var _15$snapshot$5: Snap$Bool
  var _2$address: Address
  var _2$snapshot$0: Snap$I64
  var _3$address: Address
  var _3$snapshot$0: Snap$Unbounded
  var _4$address: Address
  var _4$snapshot$0: Snap$ref$Shared$struct$m_LinkedList$
  var _4$snapshot$1: Snap$ref$Shared$struct$m_LinkedList$
  var _5$address: Address
  var _5$snapshot$0: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$
  var _6$address: Address
  var _6$snapshot$0: Snap$struct$m_LinkedList$
  var _6$snapshot$1: Snap$struct$m_LinkedList$
  var _6$snapshot$2: Snap$struct$m_LinkedList$
  var _6$snapshot$3: Snap$struct$m_LinkedList$
  var _7$address: Address
  var _7$snapshot$0: Snap$Tuple$$$
  var _7$snapshot$1: Snap$Tuple$$$
  var _7$snapshot$2: Snap$Tuple$$$
  var _8$address: Address
  var _8$snapshot$0: Snap$Bool
  var _8$snapshot$1: Snap$Bool
  var _8$snapshot$2: Snap$Bool
  var bw0$snapshot$0: Lifetime
  var bw3$snapshot$0: Lifetime
  var bw4$snapshot$0: Lifetime
  var end_label$marker: Bool
  var label_2_custom$marker: Bool
  var label_3_custom$marker: Bool
  var label_5_custom$marker: Bool
  var label_6_custom$marker: Bool
  var label_7_custom$marker: Bool
  var label_8_custom$marker: Bool
  var label_9_custom$marker: Bool
  var label_bb0$marker: Bool
  var label_bb1$marker: Bool
  var label_bb10$marker: Bool
  var label_bb11$marker: Bool
  var label_bb12$marker: Bool
  var label_bb13$marker: Bool
  var label_bb14$marker: Bool
  var label_bb2$marker: Bool
  var label_bb4$marker: Bool
  var label_bb5$marker: Bool
  var label_bb6$marker: Bool
  var label_bb7$marker: Bool
  var label_bb8$marker: Bool
  var label_bb9$marker: Bool
  var label_entry$marker: Bool
  var lft_0$snapshot$1: Lifetime
  var lft_1$snapshot$1: Lifetime
  var lft_12$snapshot$1: Lifetime
  var lft_2$snapshot$1: Lifetime
  var lft_7$alive$snapshot$0: Bool
  var lft_7$snapshot$1: Lifetime
  var lft_function_call_1$snapshot$1: Lifetime
  var lft_function_call_2$snapshot$0: Lifetime
  var lft_function_call_2$snapshot$1: Lifetime
  var lft_function_call_2$snapshot$2: Lifetime
  var lft_function_call_2$snapshot$3: Lifetime
  var lifetime_token_perm_amount$0$snapshot$0: Perm
  var resume_panic_label$marker: Bool
  var return_label$marker: Bool
  var start_label$marker: Bool
  var tmp$0: Snap$ref$Shared$struct$m_LinkedList$
  var tmp$1: Bool
  var tmp$2: Bool
  var tmp$3: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$
  var tmp$4: Snap$struct$m_LinkedList$
  label start_label
  lft_7$alive$snapshot$0 := true
  start_label$marker := false
  label_entry$marker := false
  label_bb0$marker := false
  label_3_custom$marker := false
  label_2_custom$marker := false
  label_bb1$marker := false
  label_6_custom$marker := false
  label_bb10$marker := false
  label_bb11$marker := false
  label_bb14$marker := false
  label_8_custom$marker := false
  label_bb13$marker := false
  label_9_custom$marker := false
  label_7_custom$marker := false
  label_bb12$marker := false
  resume_panic_label$marker := false
  label_5_custom$marker := false
  label_bb2$marker := false
  label_bb4$marker := false
  label_bb5$marker := false
  label_bb6$marker := false
  label_bb7$marker := false
  label_bb8$marker := false
  label_bb9$marker := false
  return_label$marker := false
  end_label$marker := false
  start_label$marker := true
  inhale basic_block_marker$start_label$marker()
  // Lifetime preconditions.
  inhale lifetime_token_perm_amount$0$snapshot$0 > none
  inhale lifetime_token_perm_amount$0$snapshot$0 < write
  inhale acc(LifetimeToken(bw3$snapshot$0), lifetime_token_perm_amount$0$snapshot$0)
  inhale acc(LifetimeToken(bw4$snapshot$0), lifetime_token_perm_amount$0$snapshot$0)
  lft_0$snapshot$1 := bw3$snapshot$0
  lft_1$snapshot$1 := lft_tok_sep_take$2(bw3$snapshot$0, bw4$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    20)
  // Allocate the parameters.
  inhale acc(OwnedNonAliased$struct$m_LinkedList$(_1$place(), _1$address, _1$snapshot$0), write) &&
    valid$Snap$struct$m_LinkedList$(_1$snapshot$0)
  inhale acc(OwnedNonAliased$I64(_2$place(), _2$address, _2$snapshot$0), write) &&
    valid$Snap$I64(_2$snapshot$0)
  // Allocate the return place.
  inhale acc(MemoryBlock(_0$address, Size$struct$m_LinkedList$$()), write)
  // Allocate implicitly allocated statements.
  inhale acc(MemoryBlock(_15$address, Size$Bool$()), write)
  goto label_entry
  label label_entry
  label_entry$marker := true
  inhale basic_block_marker$label_entry$marker()
  goto label_bb0
  label label_bb0
  label_bb0$marker := true
  inhale basic_block_marker$label_bb0$marker()
  // Prepare lifetimes for statement mid bb0[0]
  // bb0[0] _15 = const false
  write_place_constant$Bool(_15$place(), _15$address, constructor$Snap$Bool$(false))
  inhale _15$snapshot$1 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement start bb0[1]
  // Prepare lifetimes for statement mid bb0[1]
  // bb0[1] _15 = const true
  into_memory_block$Bool(_15$place(), _15$address, _15$snapshot$1)
  write_place_constant$Bool(_15$place(), _15$address, constructor$Snap$Bool$(true))
  inhale _15$snapshot$2 == constructor$Snap$Bool$(true)
  // Prepare lifetimes for statement start bb0[2]
  // Prepare lifetimes for statement mid bb0[2]
  // bb0[2] StorageLive(_3)
  inhale acc(MemoryBlock(_3$address, Size$Unbounded$()), write)
  inhale acc(MemoryBlockStackDrop(_3$address, Size$Unbounded$()), write)
  // Prepare lifetimes for statement start bb0[3]
  // Prepare lifetimes for statement mid bb0[3]
  // bb0[3] StorageLive(_4)
  inhale acc(MemoryBlock(_4$address, Size$ref$Shared$struct$m_LinkedList$$()), write)
  inhale acc(MemoryBlockStackDrop(_4$address, Size$ref$Shared$struct$m_LinkedList$$()), write)
  // Prepare lifetimes for statement start bb0[4]
  // Prepare lifetimes for statement mid bb0[4]
  bw0$snapshot$0 := newlft()
  lft_2$snapshot$1 := bw0$snapshot$0
  lft_7$snapshot$1 := bw0$snapshot$0
  // bb0[4] _4 = &_1
  tmp$0 := assign$ref$Shared$struct$m_LinkedList$$Ref$struct$m_LinkedList$$$lft_2$$(_4$place(),
    _4$address, _1$place(), _1$address, _1$snapshot$0, lft_2$snapshot$1, lifetime_token_perm_amount$0$snapshot$0 /
    20)
  inhale _4$snapshot$1 == tmp$0
  inhale _1$snapshot$1 ==
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(tmp$0)
  // Prepare lifetimes for statement mid bb0[5]
  lft_12$snapshot$1 := bw0$snapshot$0
  // bb0[5] _3 = LinkedList::len(move _4) -> [return: bb1, unwind: bb11]
  lft_function_call_1$snapshot$1 := lft_tok_sep_take$2(lft_1$snapshot$1, lft_7$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 40)
  assert included(lft_12$snapshot$1, lft_7$snapshot$1)
  consume$Move$ref$Shared$struct$m_LinkedList$(_4$place(), _4$address, _4$snapshot$1,
    lft_7$alive$snapshot$0, lft_7$snapshot$1)
  exhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    60)
  exhale acc(LifetimeToken(lft_7$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    60)
  exhale acc(LifetimeToken(lft_function_call_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    60)
  exhale acc(MemoryBlock(_3$address, Size$Unbounded$()), write)
  if (tmp$1) {
    goto label_2_custom
  }
  if (!tmp$1) {
    goto label_3_custom
  }
  assert false
  label label__from__label_3_custom__to__label_bb11
  inhale _15$snapshot$4 == _15$snapshot$2
  inhale _6$snapshot$2 == _6$snapshot$0
  inhale lft_function_call_2$snapshot$2 == lft_function_call_2$snapshot$0
  goto label_bb11
  label label_3_custom
  label_3_custom$marker := true
  inhale basic_block_marker$label_3_custom$marker()
  inhale acc(MemoryBlock(_3$address, Size$Unbounded$()), write)
  inhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  inhale acc(LifetimeToken(lft_7$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  inhale acc(LifetimeToken(lft_function_call_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  lft_tok_sep_return$2(lft_function_call_1$snapshot$1, lft_1$snapshot$1, lft_7$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 40)
  // Prepare lifetimes for block bb11
  endlft(bw0$snapshot$0)
  dead_inclusion(lft_12$snapshot$1, bw0$snapshot$0)
  dead_inclusion(lft_7$snapshot$1, bw0$snapshot$0)
  goto label__from__label_3_custom__to__label_bb11
  label label_2_custom
  label_2_custom$marker := true
  inhale basic_block_marker$label_2_custom$marker()
  inhale acc(OwnedNonAliased$Unbounded(_3$place(), _3$address, _3$snapshot$0), write) &&
    valid$Snap$Unbounded(_3$snapshot$0)
  inhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  inhale acc(LifetimeToken(lft_7$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  inhale acc(LifetimeToken(lft_function_call_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  lft_tok_sep_return$2(lft_function_call_1$snapshot$1, lft_1$snapshot$1, lft_7$snapshot$1,
    lifetime_token_perm_amount$0$snapshot$0 / 40)
  // Prepare lifetimes for block bb1
  endlft(bw0$snapshot$0)
  dead_inclusion(lft_12$snapshot$1, bw0$snapshot$0)
  dead_inclusion(lft_2$snapshot$1, bw0$snapshot$0)
  dead_inclusion(lft_7$snapshot$1, bw0$snapshot$0)
  goto label_bb1
  label label_bb1
  label_bb1$marker := true
  inhale basic_block_marker$label_bb1$marker()
  // Prepare lifetimes for statement mid bb1[0]
  // bb1[0] StorageDead(_4)
  exhale acc(MemoryBlock(_4$address, Size$ref$Shared$struct$m_LinkedList$$()), write)
  exhale acc(MemoryBlockStackDrop(_4$address, Size$ref$Shared$struct$m_LinkedList$$()), write)
  // Prepare lifetimes for statement start bb1[1]
  // Prepare lifetimes for statement mid bb1[1]
  // bb1[1] FakeRead(ForLet(None), _3)
  // encode_statement: not encoded
  // Prepare lifetimes for statement start bb1[2]
  // Prepare lifetimes for statement mid bb1[2]
  // bb1[2] StorageLive(_5)
  inhale acc(MemoryBlock(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  inhale acc(MemoryBlockStackDrop(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  // Prepare lifetimes for statement start bb1[3]
  // Prepare lifetimes for statement mid bb1[3]
  // bb1[3] StorageLive(_6)
  inhale acc(MemoryBlock(_6$address, Size$struct$m_LinkedList$$()), write)
  inhale acc(MemoryBlockStackDrop(_6$address, Size$struct$m_LinkedList$$()), write)
  // Prepare lifetimes for statement start bb1[4]
  // Prepare lifetimes for statement mid bb1[4]
  // bb1[4] _15 = const false
  into_memory_block$Bool(_15$place(), _15$address, _15$snapshot$2)
  write_place_constant$Bool(_15$place(), _15$address, constructor$Snap$Bool$(false))
  inhale _15$snapshot$3 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement start bb1[5]
  // Prepare lifetimes for statement mid bb1[5]
  // bb1[5] _6 = move _1
  apply acc(DeadLifetimeToken(lft_2$snapshot$1), write) --*
    acc(OwnedNonAliased$struct$m_LinkedList$(_1$place(), _1$address, _1$snapshot$1), write) &&
    valid$Snap$struct$m_LinkedList$(_1$snapshot$1) &&
    acc(DeadLifetimeToken(lft_2$snapshot$1), write)
  move_place$struct$m_LinkedList$(_6$place(), _6$address, _1$place(), _1$address,
    _1$snapshot$1)
  inhale _6$snapshot$1 == _1$snapshot$1
  // Prepare lifetimes for statement mid bb1[6]
  // bb1[6] _5 = BoxWrapper::<LinkedList>::new(move _6) -> [return: bb2, unwind: bb10]
  lft_function_call_2$snapshot$1 := lft_1$snapshot$1
  consume$Move$struct$m_LinkedList$(_6$place(), _6$address, _6$snapshot$1)
  exhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  exhale acc(LifetimeToken(lft_function_call_2$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    40)
  exhale acc(MemoryBlock(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  if (tmp$2) {
    goto label_5_custom
  }
  if (!tmp$2) {
    goto label_6_custom
  }
  assert false
  label label_6_custom
  label_6_custom$marker := true
  inhale basic_block_marker$label_6_custom$marker()
  inhale acc(MemoryBlock(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  inhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    20)
  inhale acc(LifetimeToken(lft_function_call_2$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    20)
  // Prepare lifetimes for block bb10
  goto label_bb10
  label label__from__label_bb10__to__label_bb11
  inhale _15$snapshot$4 == _15$snapshot$3
  inhale _6$snapshot$2 == _6$snapshot$1
  inhale lft_function_call_2$snapshot$2 == lft_function_call_2$snapshot$1
  goto label_bb11
  label label_bb10
  label_bb10$marker := true
  inhale basic_block_marker$label_bb10$marker()
  // Prepare lifetimes for statement mid bb10[0]
  // bb10[0] goto -> bb11
  // Prepare lifetimes for block bb11
  goto label__from__label_bb10__to__label_bb11
  label label_bb11
  label_bb11$marker := true
  inhale basic_block_marker$label_bb11$marker()
  // Prepare lifetimes for statement mid bb11[0]
  // bb11[0] goto -> bb14
  // Prepare lifetimes for block bb14
  goto label_bb14
  label label_bb14
  label_bb14$marker := true
  inhale basic_block_marker$label_bb14$marker()
  // Prepare lifetimes for statement mid bb14[0]
  // bb14[0] switchInt(_15) -> [0: bb12, otherwise: bb13]
  if (!destructor$Snap$Bool$$value(_15$snapshot$4)) {
    goto label_7_custom
  }
  if (true) {
    goto label_8_custom
  }
  assert false
  label label_8_custom
  label_8_custom$marker := true
  inhale basic_block_marker$label_8_custom$marker()
  // Prepare lifetimes for block bb13
  goto label_bb13
  label label_bb13
  label_bb13$marker := true
  inhale basic_block_marker$label_bb13$marker()
  // Prepare lifetimes for statement mid bb13[0]
  // bb13[0] drop(_1) -> [return: bb12, unwind terminate(cleanup)]
  if (label_3_custom$marker && label_bb11$marker && label_bb14$marker &&
  label_8_custom$marker) {
    apply acc(DeadLifetimeToken(lft_2$snapshot$1), write) --*
      acc(OwnedNonAliased$struct$m_LinkedList$(_1$place(), _1$address, _1$snapshot$1), write) &&
      valid$Snap$struct$m_LinkedList$(_1$snapshot$1) &&
      acc(DeadLifetimeToken(lft_2$snapshot$1), write)
  }
  if (label_bb10$marker && label_bb11$marker && label_bb14$marker &&
  label_8_custom$marker) {
    assert false
  }
  consume$Move$struct$m_LinkedList$(_1$place(), _1$address, _1$snapshot$1)
  goto label_9_custom
  label label_9_custom
  label_9_custom$marker := true
  inhale basic_block_marker$label_9_custom$marker()
  // Prepare lifetimes for block bb12
  goto label_bb12
  label label_7_custom
  label_7_custom$marker := true
  inhale basic_block_marker$label_7_custom$marker()
  // Prepare lifetimes for block bb12
  goto label_bb12
  label label_bb12
  label_bb12$marker := true
  inhale basic_block_marker$label_bb12$marker()
  // Prepare lifetimes for statement mid bb12[0]
  // bb12[0] resume
  goto resume_panic_label
  label label__from__resume_panic_label__to__end_label
  inhale _0$snapshot$2 == _0$snapshot$0
  inhale _12$snapshot$2 == _12$snapshot$0
  inhale _13$snapshot$2 == _13$snapshot$0
  inhale _14$snapshot$2 == _14$snapshot$0
  inhale _15$snapshot$5 == _15$snapshot$4
  inhale _6$snapshot$3 == _6$snapshot$2
  inhale _7$snapshot$2 == _7$snapshot$0
  inhale _8$snapshot$2 == _8$snapshot$0
  inhale lft_function_call_2$snapshot$3 == lft_function_call_2$snapshot$2
  goto end_label
  label resume_panic_label
  resume_panic_label$marker := true
  inhale basic_block_marker$resume_panic_label$marker()
  goto label__from__resume_panic_label__to__end_label
  label label_5_custom
  label_5_custom$marker := true
  inhale basic_block_marker$label_5_custom$marker()
  inhale acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(_5$place(),
    _5$address, _5$snapshot$0), write) &&
    valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(_5$snapshot$0)
  inhale acc(LifetimeToken(lft_1$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    20)
  inhale acc(LifetimeToken(lft_function_call_2$snapshot$1), lifetime_token_perm_amount$0$snapshot$0 /
    20)
  // Prepare lifetimes for block bb2
  goto label_bb2
  label label_bb2
  label_bb2$marker := true
  inhale basic_block_marker$label_bb2$marker()
  // Prepare lifetimes for statement mid bb2[0]
  // bb2[0] StorageDead(_6)
  exhale acc(MemoryBlock(_6$address, Size$struct$m_LinkedList$$()), write)
  exhale acc(MemoryBlockStackDrop(_6$address, Size$struct$m_LinkedList$$()), write)
  // Prepare lifetimes for statement start bb2[1]
  // Prepare lifetimes for statement mid bb2[1]
  // bb2[1] FakeRead(ForLet(None), _5)
  // encode_statement: not encoded
  // Prepare lifetimes for statement start bb2[2]
  // Prepare lifetimes for statement mid bb2[2]
  // bb2[2] StorageLive(_7)
  inhale acc(MemoryBlock(_7$address, Size$Tuple$$$$()), write)
  inhale acc(MemoryBlockStackDrop(_7$address, Size$Tuple$$$$()), write)
  // Prepare lifetimes for statement start bb2[3]
  // Prepare lifetimes for statement mid bb2[3]
  // bb2[3] StorageLive(_8)
  inhale acc(MemoryBlock(_8$address, Size$Bool$()), write)
  inhale acc(MemoryBlockStackDrop(_8$address, Size$Bool$()), write)
  // Prepare lifetimes for statement start bb2[4]
  // Prepare lifetimes for statement mid bb2[4]
  // bb2[4] _8 = const false
  write_place_constant$Bool(_8$place(), _8$address, constructor$Snap$Bool$(false))
  inhale _8$snapshot$1 == constructor$Snap$Bool$(false)
  // Prepare lifetimes for statement mid bb2[5]
  // bb2[5] switchInt(move _8) -> [0: bb4, otherwise: bb3]
  // Specification from block: bb3
  // Prepare lifetimes for block bb4
  goto label_bb4
  label label_bb4
  label_bb4$marker := true
  inhale basic_block_marker$label_bb4$marker()
  // Prepare lifetimes for statement mid bb4[0]
  // bb4[0] _7 = const ()
  write_place_constant$Tuple$$$(_7$place(), _7$address, constructor$Snap$Tuple$$$$())
  inhale _7$snapshot$1 == constructor$Snap$Tuple$$$$()
  // Prepare lifetimes for statement mid bb4[1]
  // bb4[1] goto -> bb5
  // Prepare lifetimes for block bb5
  goto label_bb5
  label label_bb5
  label_bb5$marker := true
  inhale basic_block_marker$label_bb5$marker()
  // Prepare lifetimes for statement mid bb5[0]
  // bb5[0] StorageDead(_8)
  into_memory_block$Bool(_8$place(), _8$address, _8$snapshot$1)
  exhale acc(MemoryBlock(_8$address, Size$Bool$()), write)
  exhale acc(MemoryBlockStackDrop(_8$address, Size$Bool$()), write)
  // Prepare lifetimes for statement start bb5[1]
  // Prepare lifetimes for statement mid bb5[1]
  // bb5[1] StorageDead(_7)
  into_memory_block$Tuple$$$(_7$place(), _7$address, _7$snapshot$1)
  exhale acc(MemoryBlock(_7$address, Size$Tuple$$$$()), write)
  exhale acc(MemoryBlockStackDrop(_7$address, Size$Tuple$$$$()), write)
  // Prepare lifetimes for statement start bb5[2]
  // Prepare lifetimes for statement mid bb5[2]
  // bb5[2] StorageLive(_12)
  inhale acc(MemoryBlock(_12$address, Size$I64$()), write)
  inhale acc(MemoryBlockStackDrop(_12$address, Size$I64$()), write)
  // Prepare lifetimes for statement start bb5[3]
  // Prepare lifetimes for statement mid bb5[3]
  // bb5[3] _12 = _2
  copy_place$I64(_12$place(), _12$address, _2$place(), _2$address, _2$snapshot$0,
    write)
  inhale _12$snapshot$1 == _2$snapshot$0
  // Prepare lifetimes for statement start bb5[4]
  // Prepare lifetimes for statement mid bb5[4]
  // bb5[4] StorageLive(_13)
  inhale acc(MemoryBlock(_13$address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  inhale acc(MemoryBlockStackDrop(_13$address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  // Prepare lifetimes for statement start bb5[5]
  // Prepare lifetimes for statement mid bb5[5]
  // bb5[5] StorageLive(_14)
  inhale acc(MemoryBlock(_14$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  inhale acc(MemoryBlockStackDrop(_14$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  // Prepare lifetimes for statement start bb5[6]
  // Prepare lifetimes for statement mid bb5[6]
  // bb5[6] _14 = move _5
  move_place$trusted$m_BoxWrapper$struct$m_LinkedList$$(_14$place(), _14$address,
    _5$place(), _5$address, _5$snapshot$0)
  inhale _14$snapshot$1 == _5$snapshot$0
  // Prepare lifetimes for statement start bb5[7]
  // Prepare lifetimes for statement mid bb5[7]
  // bb5[7] _13 = std::option::Option::<BoxWrapper<LinkedList>>::Some(move _14)
  tmp$3 := assign$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Aggregate$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$$$(_13$place(),
    _13$address, _14$place(), _14$address, _14$snapshot$1)
  inhale _13$snapshot$1 == tmp$3
  // Prepare lifetimes for statement mid bb5[8]
  // bb5[8] goto -> bb6
  // Prepare lifetimes for block bb6
  goto label_bb6
  label label_bb6
  label_bb6$marker := true
  inhale basic_block_marker$label_bb6$marker()
  // Prepare lifetimes for statement mid bb6[0]
  // bb6[0] StorageDead(_14)
  exhale acc(MemoryBlock(_14$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  exhale acc(MemoryBlockStackDrop(_14$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  // Prepare lifetimes for statement start bb6[1]
  // Prepare lifetimes for statement mid bb6[1]
  // bb6[1] _0 = LinkedList { val: move _12, next: move _13 }
  tmp$4 := assign$struct$m_LinkedList$$Aggregate$struct$m_LinkedList$$$$$(_0$place(),
    _0$address, _12$place(), _12$address, _12$snapshot$1, _13$place(), _13$address,
    _13$snapshot$1)
  inhale _0$snapshot$1 == tmp$4
  // Prepare lifetimes for statement mid bb6[2]
  // bb6[2] goto -> bb7
  // Prepare lifetimes for block bb7
  goto label_bb7
  label label_bb7
  label_bb7$marker := true
  inhale basic_block_marker$label_bb7$marker()
  // Prepare lifetimes for statement mid bb7[0]
  // bb7[0] StorageDead(_13)
  exhale acc(MemoryBlock(_13$address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  exhale acc(MemoryBlockStackDrop(_13$address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  // Prepare lifetimes for statement start bb7[1]
  // Prepare lifetimes for statement mid bb7[1]
  // bb7[1] StorageDead(_12)
  exhale acc(MemoryBlock(_12$address, Size$I64$()), write)
  exhale acc(MemoryBlockStackDrop(_12$address, Size$I64$()), write)
  // Prepare lifetimes for statement mid bb7[2]
  // bb7[2] goto -> bb8
  // Prepare lifetimes for block bb8
  goto label_bb8
  label label_bb8
  label_bb8$marker := true
  inhale basic_block_marker$label_bb8$marker()
  // Prepare lifetimes for statement mid bb8[0]
  // bb8[0] StorageDead(_5)
  exhale acc(MemoryBlock(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  exhale acc(MemoryBlockStackDrop(_5$address, Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  // Prepare lifetimes for statement start bb8[1]
  // Prepare lifetimes for statement mid bb8[1]
  // bb8[1] StorageDead(_3)
  into_memory_block$Unbounded(_3$place(), _3$address, _3$snapshot$0)
  exhale acc(MemoryBlock(_3$address, Size$Unbounded$()), write)
  exhale acc(MemoryBlockStackDrop(_3$address, Size$Unbounded$()), write)
  // Prepare lifetimes for statement mid bb8[2]
  // bb8[2] goto -> bb9
  // Prepare lifetimes for block bb9
  goto label_bb9
  label label_bb9
  label_bb9$marker := true
  inhale basic_block_marker$label_bb9$marker()
  // Prepare lifetimes for statement mid bb9[0]
  // bb9[0] return
  goto return_label
  label label__from__return_label__to__end_label
  inhale _0$snapshot$2 == _0$snapshot$1
  inhale _12$snapshot$2 == _12$snapshot$1
  inhale _13$snapshot$2 == _13$snapshot$1
  inhale _14$snapshot$2 == _14$snapshot$1
  inhale _15$snapshot$5 == _15$snapshot$3
  inhale _6$snapshot$3 == _6$snapshot$1
  inhale _7$snapshot$2 == _7$snapshot$1
  inhale _8$snapshot$2 == _8$snapshot$1
  inhale lft_function_call_2$snapshot$3 == lft_function_call_2$snapshot$1
  goto end_label
  label return_label
  return_label$marker := true
  inhale basic_block_marker$return_label$marker()
  // Deallocate the parameters.
  exhale acc(MemoryBlock(_1$address, Size$struct$m_LinkedList$$()), write)
  into_memory_block$I64(_2$place(), _2$address, _2$snapshot$0)
  exhale acc(MemoryBlock(_2$address, Size$I64$()), write)
  // Deallocate the return place.
  exhale acc(OwnedNonAliased$struct$m_LinkedList$(_0$place(), _0$address, _0$snapshot$1), write) &&
    valid$Snap$struct$m_LinkedList$(_0$snapshot$1)
  // Lifetime postconditions.
  lft_tok_sep_return$2(lft_1$snapshot$1, bw3$snapshot$0, bw4$snapshot$0, lifetime_token_perm_amount$0$snapshot$0 /
    20)
  exhale acc(LifetimeToken(bw3$snapshot$0), lifetime_token_perm_amount$0$snapshot$0)
  exhale acc(LifetimeToken(bw4$snapshot$0), lifetime_token_perm_amount$0$snapshot$0)
  into_memory_block$Bool(_15$place(), _15$address, _15$snapshot$3)
  exhale acc(MemoryBlock(_15$address, Size$Bool$()), write)
  goto label__from__return_label__to__end_label
  label end_label
  end_label$marker := true
  inhale basic_block_marker$end_label$marker()
  goto end_of_method
  label end_of_method
}

method assign$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Aggregate$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$$$(target_place: Place,
  target_address: Address, operand0_place: Place, operand0_root_address: Address,
  operand0_value: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$)
  returns (result_value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(MemoryBlock(compute_address(target_place, target_address), Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  requires acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(operand0_place,
    operand0_root_address, operand0_value), write)
  requires valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(operand0_value)
  ensures acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_address, result_value), write)
  ensures acc(MemoryBlock(compute_address(operand0_place, operand0_root_address),
    Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  ensures valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(operand0_value)))
  ensures result_value ==
    constructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some(constructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$(operand0_value))
  ensures valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(result_value)


method assign$ref$Shared$struct$m_LinkedList$$Ref$struct$m_LinkedList$$$lft_2$$(target_place: Place,
  target_address: Address, operand_place: Place, operand_root_address: Address,
  operand_snapshot: Snap$struct$m_LinkedList$, lft_2: Lifetime, lifetime_perm: Perm)
  returns (result_value: Snap$ref$Shared$struct$m_LinkedList$)
  requires acc(MemoryBlock(compute_address(target_place, target_address), Size$ref$Shared$struct$m_LinkedList$$()), write)
  requires none < lifetime_perm
  requires lifetime_perm < write
  requires acc(OwnedNonAliased$struct$m_LinkedList$(operand_place, operand_root_address,
    operand_snapshot), write)
  requires acc(LifetimeToken(lft_2), lifetime_perm)
  requires valid$Snap$struct$m_LinkedList$(operand_snapshot)
  ensures operand_root_address ==
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$address(result_value)
  ensures operand_snapshot ==
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(result_value)
  ensures acc(LifetimeToken(lft_2), lifetime_perm)
  ensures acc(OwnedNonAliased$ref$Shared$struct$m_LinkedList$(target_place,
    target_address, result_value, true, lft_2), write)
  ensures acc(DeadLifetimeToken(lft_2), write) --*
    acc(OwnedNonAliased$struct$m_LinkedList$(operand_place, operand_root_address,
    destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(result_value)), write) &&
    valid$Snap$struct$m_LinkedList$(destructor$Snap$ref$Shared$struct$m_LinkedList$$$target_current(result_value)) &&
    acc(DeadLifetimeToken(lft_2), write)
  ensures valid$Snap$ref$Shared$struct$m_LinkedList$(result_value)


method assign$struct$m_LinkedList$$Aggregate$struct$m_LinkedList$$$$$(target_place: Place,
  target_address: Address, operand0_place: Place, operand0_root_address: Address,
  operand0_value: Snap$I64, operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  returns (result_value: Snap$struct$m_LinkedList$)
  requires acc(MemoryBlock(compute_address(target_place, target_address), Size$struct$m_LinkedList$$()), write)
  requires acc(OwnedNonAliased$I64(operand0_place, operand0_root_address, operand0_value), write)
  requires valid$Snap$I64(operand0_value)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(operand1_place,
    operand1_root_address, operand1_value), write)
  requires valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(operand1_value)
  ensures acc(OwnedNonAliased$struct$m_LinkedList$(target_place, target_address,
    result_value), write)
  ensures acc(MemoryBlock(compute_address(operand0_place, operand0_root_address),
    Size$I64$()), write)
  ensures acc(MemoryBlock(compute_address(operand1_place, operand1_root_address),
    Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures valid$Snap$struct$m_LinkedList$(constructor$Snap$struct$m_LinkedList$$(operand0_value,
    operand1_value))
  ensures result_value ==
    constructor$Snap$struct$m_LinkedList$$(operand0_value, operand1_value)
  ensures valid$Snap$struct$m_LinkedList$(result_value)


method consume$Move$ref$Shared$struct$m_LinkedList$(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$ref$Shared$struct$m_LinkedList$, lft_7$alive: Bool, lft_7: Lifetime)
  requires acc(OwnedNonAliased$ref$Shared$struct$m_LinkedList$(operand1_place,
    operand1_root_address, operand1_value, lft_7$alive, lft_7), write)
  requires valid$Snap$ref$Shared$struct$m_LinkedList$(operand1_value)
  ensures acc(MemoryBlock(compute_address(operand1_place, operand1_root_address),
    Size$ref$Shared$struct$m_LinkedList$$()), write)


method consume$Move$struct$m_LinkedList$(operand1_place: Place, operand1_root_address: Address,
  operand1_value: Snap$struct$m_LinkedList$)
  requires acc(OwnedNonAliased$struct$m_LinkedList$(operand1_place, operand1_root_address,
    operand1_value), write)
  requires valid$Snap$struct$m_LinkedList$(operand1_value)
  ensures acc(MemoryBlock(compute_address(operand1_place, operand1_root_address),
    Size$struct$m_LinkedList$$()), write)


method copy_place$I64(target_place: Place, target_root_address: Address, source_place: Place,
  source_root_address: Address, source_snapshot: Snap$I64, source_permission_amount: Perm)
  requires none < source_permission_amount
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$I64$()), write)
  requires acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), source_permission_amount)
  ensures acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), source_permission_amount)
  ensures acc(OwnedNonAliased$I64(target_place, target_root_address, source_snapshot), write)
  ensures valid$Snap$I64(source_snapshot)
{
  unfold acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), source_permission_amount)
  memory_copy$I64(compute_address(source_place, source_root_address), compute_address(target_place,
    target_root_address), source_permission_amount)
  fold acc(OwnedNonAliased$I64(target_place, target_root_address, source_snapshot), write)
  fold acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), source_permission_amount)
}

method dead_inclusion(lft_1: Lifetime, lft_2: Lifetime)
  requires acc(DeadLifetimeToken(lft_2), write)
  requires included(lft_1, lft_2)
  ensures acc(DeadLifetimeToken(lft_1), write)
  ensures acc(DeadLifetimeToken(lft_2), write)


method endlft(bw: Lifetime)
  requires acc(LifetimeToken(bw), write)
  ensures acc(DeadLifetimeToken(bw), write)


method into_memory_block$Bool(place: Place, root_address: Address, snapshot: Snap$Bool)
  requires acc(OwnedNonAliased$Bool(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$Bool$()), write)
{
  unfold acc(OwnedNonAliased$Bool(place, root_address, snapshot), write)
}

method into_memory_block$I64(place: Place, root_address: Address, snapshot: Snap$I64)
  requires acc(OwnedNonAliased$I64(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$I64$()), write)
{
  unfold acc(OwnedNonAliased$I64(place, root_address, snapshot), write)
}

method into_memory_block$Isize(place: Place, root_address: Address, snapshot: Snap$Isize)
  requires acc(OwnedNonAliased$Isize(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$Isize$()), write)
{
  unfold acc(OwnedNonAliased$Isize(place, root_address, snapshot), write)
}

method into_memory_block$Tuple$$$(place: Place, root_address: Address, snapshot: Snap$Tuple$$$)
  requires acc(OwnedNonAliased$Tuple$$$(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$Tuple$$$$()), write)
{
  unfold acc(OwnedNonAliased$Tuple$$$(place, root_address, snapshot), write)
  memory_block_join$Tuple$$$(compute_address(place, root_address), write)
}

method into_memory_block$Unbounded(place: Place, root_address: Address, snapshot: Snap$Unbounded)
  requires acc(OwnedNonAliased$Unbounded(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$Unbounded$()), write)
{
  unfold acc(OwnedNonAliased$Unbounded(place, root_address, snapshot), write)
}

method into_memory_block$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  memory_block_join$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(place,
    root_address), write)
}

method into_memory_block$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  into_memory_block$trusted$m_BoxWrapper$struct$m_LinkedList$$(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(place),
    root_address, destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot))
  memory_block_join$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(place,
    root_address), write)
}

method into_memory_block$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place: Place,
  root_address: Address, snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(place,
    root_address, snapshot), write)
  into_memory_block$Isize(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(place),
    root_address, constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot)))
  if (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
  0) {
    into_memory_block$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(place),
      root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot))
  }
  if (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==
  1) {
    into_memory_block$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(place),
      root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot))
  }
  memory_block_join$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(place,
    root_address), write, discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))
}

method into_memory_block$struct$m_LinkedList$(place: Place, root_address: Address,
  snapshot: Snap$struct$m_LinkedList$)
  requires acc(OwnedNonAliased$struct$m_LinkedList$(place, root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$struct$m_LinkedList$$()), write)
{
  unfold acc(OwnedNonAliased$struct$m_LinkedList$(place, root_address, snapshot), write)
  into_memory_block$I64(field_place$$struct$m_LinkedList$$$f$val(place), root_address,
    destructor$Snap$struct$m_LinkedList$$$f$val(snapshot))
  into_memory_block$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(field_place$$struct$m_LinkedList$$$f$next(place),
    root_address, destructor$Snap$struct$m_LinkedList$$$f$next(snapshot))
  memory_block_join$struct$m_LinkedList$(compute_address(place, root_address),
    write)
}

method into_memory_block$trusted$m_BoxWrapper$struct$m_LinkedList$$(place: Place,
  root_address: Address, snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$)
  requires acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(place,
    root_address, snapshot), write)
  ensures acc(MemoryBlock(compute_address(place, root_address), Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)


method lft_tok_sep_return$2(lft: Lifetime, lft_1: Lifetime, lft_2: Lifetime,
  rd_perm: Perm)
  requires none < rd_perm
  requires acc(LifetimeToken(lft), rd_perm)
  requires lft == intersect(Set(lft_1, lft_2))
  ensures acc(LifetimeToken(lft_1), rd_perm)
  ensures acc(LifetimeToken(lft_2), rd_perm)


method lft_tok_sep_take$2(lft_1: Lifetime, lft_2: Lifetime, rd_perm: Perm)
  returns (lft: Lifetime)
  requires none < rd_perm
  requires acc(LifetimeToken(lft_1), rd_perm)
  requires acc(LifetimeToken(lft_2), rd_perm)
  ensures acc(LifetimeToken(lft), rd_perm)
  ensures lft == intersect(Set(lft_1, lft_2))


method memory_block_join$Tuple$$$(address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, PaddingSize$Tuple$$$$()), permission_amount)
  ensures acc(MemoryBlock(address, Size$Tuple$$$$()), write)
  ensures (forall snapshot: Snap$Tuple$$$ ::
      { to_bytes$Tuple$$$(snapshot) }
      MemoryBlock$bytes(address, Size$Tuple$$$$()) ==
      to_bytes$Tuple$$$(snapshot))


method memory_block_join$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures (forall snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { to_bytes$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      MemoryBlock$bytes(address, Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))


method memory_block_join$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  requires acc(MemoryBlock(field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(address),
    Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), permission_amount)
  ensures acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures (forall snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      old(MemoryBlock$bytes(field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(address),
      Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()) ==
      to_bytes$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot))) ==>
      MemoryBlock$bytes(address, Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))


method memory_block_join$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm, discriminant: Int)
  requires none < permission_amount
  requires acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  requires acc(MemoryBlock(field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(address),
    Size$Isize$()), write)
  requires discriminant == 0 ==>
    acc(MemoryBlock(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(address),
    Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  requires discriminant == 1 ==>
    acc(MemoryBlock(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(address),
    Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures (forall snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      (discriminant == 0 ==>
      old(MemoryBlock$bytes(field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(address),
      Size$Isize$())) ==
      to_bytes$Isize(constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))) &&
      old(MemoryBlock$bytes(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(address),
      Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$())) ==
      to_bytes$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(snapshot)) ==>
      MemoryBlock$bytes(address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot)) &&
      (discriminant == 1 ==>
      old(MemoryBlock$bytes(field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(address),
      Size$Isize$())) ==
      to_bytes$Isize(constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot))) &&
      old(MemoryBlock$bytes(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(address),
      Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$())) ==
      to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(snapshot)) ==>
      MemoryBlock$bytes(address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot)))


method memory_block_join$struct$m_LinkedList$(address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, PaddingSize$struct$m_LinkedList$$()), permission_amount)
  requires acc(MemoryBlock(field_address$$struct$m_LinkedList$$$f$val(address),
    Size$I64$()), permission_amount)
  requires acc(MemoryBlock(field_address$$struct$m_LinkedList$$$f$next(address),
    Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures acc(MemoryBlock(address, Size$struct$m_LinkedList$$()), write)
  ensures (forall snapshot: Snap$struct$m_LinkedList$ ::
      { to_bytes$struct$m_LinkedList$(snapshot) }
      old(MemoryBlock$bytes(field_address$$struct$m_LinkedList$$$f$val(address),
      Size$I64$()) ==
      to_bytes$I64(destructor$Snap$struct$m_LinkedList$$$f$val(snapshot))) &&
      old(MemoryBlock$bytes(field_address$$struct$m_LinkedList$$$f$next(address),
      Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$struct$m_LinkedList$$$f$next(snapshot))) ==>
      MemoryBlock$bytes(address, Size$struct$m_LinkedList$$()) ==
      to_bytes$struct$m_LinkedList$(snapshot))


method memory_block_split$Tuple$$$(address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, Size$Tuple$$$$()), write)
  ensures acc(MemoryBlock(address, PaddingSize$Tuple$$$$()), permission_amount)
  ensures true


method memory_block_split$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures true


method memory_block_split$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures acc(MemoryBlock(field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(address),
    Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), permission_amount)
  ensures (forall snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$ ::
      { to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) }
      old(MemoryBlock$bytes(address, Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$())) ==
      to_bytes$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(snapshot) ==>
      MemoryBlock$bytes(field_address$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(address),
      Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()) ==
      to_bytes$trusted$m_BoxWrapper$struct$m_LinkedList$$(destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(snapshot)))


method memory_block_split$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(address: Address,
  permission_amount: Perm, discriminant: Int)
  requires none < permission_amount
  requires acc(MemoryBlock(address, Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures acc(MemoryBlock(address, PaddingSize$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures acc(MemoryBlock(field_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(address),
    Size$Isize$()), write)
  ensures discriminant == 0 ==>
    acc(MemoryBlock(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(address),
    Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures discriminant == 1 ==>
    acc(MemoryBlock(variant_address$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(address),
    Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)


method memory_block_split$struct$m_LinkedList$(address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(address, Size$struct$m_LinkedList$$()), write)
  ensures acc(MemoryBlock(address, PaddingSize$struct$m_LinkedList$$()), permission_amount)
  ensures acc(MemoryBlock(field_address$$struct$m_LinkedList$$$f$val(address),
    Size$I64$()), permission_amount)
  ensures acc(MemoryBlock(field_address$$struct$m_LinkedList$$$f$next(address),
    Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), permission_amount)
  ensures (forall snapshot: Snap$struct$m_LinkedList$ ::
      { to_bytes$struct$m_LinkedList$(snapshot) }
      old(MemoryBlock$bytes(address, Size$struct$m_LinkedList$$())) ==
      to_bytes$struct$m_LinkedList$(snapshot) ==>
      MemoryBlock$bytes(field_address$$struct$m_LinkedList$$$f$val(address),
      Size$I64$()) ==
      to_bytes$I64(destructor$Snap$struct$m_LinkedList$$$f$val(snapshot)) &&
      MemoryBlock$bytes(field_address$$struct$m_LinkedList$$$f$next(address),
      Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()) ==
      to_bytes$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(destructor$Snap$struct$m_LinkedList$$$f$next(snapshot)))


method memory_copy$I64(source_address: Address, target_address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(target_address, Size$I64$()), write)
  requires acc(MemoryBlock(source_address, Size$I64$()), permission_amount)
  ensures acc(MemoryBlock(target_address, Size$I64$()), write)
  ensures acc(MemoryBlock(source_address, Size$I64$()), permission_amount)
  ensures MemoryBlock$bytes(source_address, Size$I64$()) ==
    old(MemoryBlock$bytes(source_address, Size$I64$()))
  ensures MemoryBlock$bytes(target_address, Size$I64$()) ==
    MemoryBlock$bytes(source_address, Size$I64$())


method memory_copy$Isize(source_address: Address, target_address: Address, permission_amount: Perm)
  requires none < permission_amount
  requires acc(MemoryBlock(target_address, Size$Isize$()), write)
  requires acc(MemoryBlock(source_address, Size$Isize$()), permission_amount)
  ensures acc(MemoryBlock(target_address, Size$Isize$()), write)
  ensures acc(MemoryBlock(source_address, Size$Isize$()), permission_amount)
  ensures MemoryBlock$bytes(source_address, Size$Isize$()) ==
    old(MemoryBlock$bytes(source_address, Size$Isize$()))
  ensures MemoryBlock$bytes(target_address, Size$Isize$()) ==
    MemoryBlock$bytes(source_address, Size$Isize$())


method move_place$I64(target_place: Place, target_root_address: Address, source_place: Place,
  source_root_address: Address, source_snapshot: Snap$I64)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$I64$()), write)
  requires acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$I64(target_place, target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$I64$()), write)
  ensures valid$Snap$I64(source_snapshot)
{
  unfold acc(OwnedNonAliased$I64(source_place, source_root_address, source_snapshot), write)
  memory_copy$I64(compute_address(source_place, source_root_address), compute_address(target_place,
    target_root_address), write)
  fold acc(OwnedNonAliased$I64(target_place, target_root_address, source_snapshot), write)
}

method move_place$Isize(target_place: Place, target_root_address: Address, source_place: Place,
  source_root_address: Address, source_snapshot: Snap$Isize)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$Isize$()), write)
  requires acc(OwnedNonAliased$Isize(source_place, source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$Isize(target_place, target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$Isize$()), write)
  ensures valid$Snap$Isize(source_snapshot)
{
  unfold acc(OwnedNonAliased$Isize(source_place, source_root_address, source_snapshot), write)
  memory_copy$Isize(compute_address(source_place, source_root_address), compute_address(target_place,
    target_root_address), write)
  fold acc(OwnedNonAliased$Isize(target_place, target_root_address, source_snapshot), write)
}

method move_place$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place: Place,
  target_root_address: Address, source_place: Place, source_root_address: Address,
  source_snapshot: Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures valid$Snap$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  memory_block_split$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(target_place,
    target_root_address), write)
  memory_block_join$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(source_place,
    source_root_address), write)
  fold acc(OwnedNonAliased$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
}

method move_place$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place: Place,
  target_root_address: Address, source_place: Place, source_root_address: Address,
  source_snapshot: Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures valid$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  memory_block_split$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(target_place,
    target_root_address), write)
  move_place$trusted$m_BoxWrapper$struct$m_LinkedList$$(field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(target_place),
    target_root_address, field_place$$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(source_place),
    source_root_address, destructor$Snap$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$f$0(source_snapshot))
  memory_block_join$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(source_place,
    source_root_address), write)
  fold acc(OwnedNonAliased$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
}

method move_place$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place: Place,
  target_root_address: Address, source_place: Place, source_root_address: Address,
  source_snapshot: Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  requires acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$()), write)
  ensures valid$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot)
{
  unfold acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_place,
    source_root_address, source_snapshot), write)
  memory_block_split$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(target_place,
    target_root_address), write, discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot))
  if (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot) ==
  0) {
    move_place$enum$m_std$$option$$Option$None$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(target_place),
      target_root_address, variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$None(source_place),
      source_root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$None$value(source_snapshot))
  }
  if (discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot) ==
  1) {
    move_place$enum$m_std$$option$$Option$Some$trusted$m_BoxWrapper$struct$m_LinkedList$$$(variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(target_place),
      target_root_address, variant_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$Some(source_place),
      source_root_address, destructor$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$Some$value(source_snapshot))
  }
  move_place$Isize(field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(target_place),
    target_root_address, field_place$$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$$$discriminant(source_place),
    source_root_address, constructor$Snap$Isize$(discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot)))
  memory_block_join$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(compute_address(source_place,
    source_root_address), write, discriminant$Snap$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(source_snapshot))
  fold acc(OwnedNonAliased$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(target_place,
    target_root_address, source_snapshot), write)
}

method move_place$struct$m_LinkedList$(target_place: Place, target_root_address: Address,
  source_place: Place, source_root_address: Address, source_snapshot: Snap$struct$m_LinkedList$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$struct$m_LinkedList$$()), write)
  requires acc(OwnedNonAliased$struct$m_LinkedList$(source_place, source_root_address,
    source_snapshot), write)
  ensures acc(OwnedNonAliased$struct$m_LinkedList$(target_place, target_root_address,
    source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$struct$m_LinkedList$$()), write)
  ensures valid$Snap$struct$m_LinkedList$(source_snapshot)
{
  unfold acc(OwnedNonAliased$struct$m_LinkedList$(source_place, source_root_address,
    source_snapshot), write)
  memory_block_split$struct$m_LinkedList$(compute_address(target_place, target_root_address),
    write)
  move_place$I64(field_place$$struct$m_LinkedList$$$f$val(target_place), target_root_address,
    field_place$$struct$m_LinkedList$$$f$val(source_place), source_root_address,
    destructor$Snap$struct$m_LinkedList$$$f$val(source_snapshot))
  move_place$enum$m_std$$option$$Option$_$trusted$m_BoxWrapper$struct$m_LinkedList$$$(field_place$$struct$m_LinkedList$$$f$next(target_place),
    target_root_address, field_place$$struct$m_LinkedList$$$f$next(source_place),
    source_root_address, destructor$Snap$struct$m_LinkedList$$$f$next(source_snapshot))
  memory_block_join$struct$m_LinkedList$(compute_address(source_place, source_root_address),
    write)
  fold acc(OwnedNonAliased$struct$m_LinkedList$(target_place, target_root_address,
    source_snapshot), write)
}

method move_place$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_place: Place,
  target_root_address: Address, source_place: Place, source_root_address: Address,
  source_snapshot: Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  requires acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(source_place,
    source_root_address, source_snapshot), write)
  ensures acc(OwnedNonAliased$trusted$m_BoxWrapper$struct$m_LinkedList$$(target_place,
    target_root_address, source_snapshot), write)
  ensures acc(MemoryBlock(compute_address(source_place, source_root_address),
    Size$trusted$m_BoxWrapper$struct$m_LinkedList$$$()), write)
  ensures valid$Snap$trusted$m_BoxWrapper$struct$m_LinkedList$$(source_snapshot)


method newlft() returns (bw: Lifetime)
  ensures acc(LifetimeToken(bw), write)


method write_address_constant$Bool(target_address: Address, source_snapshot: Snap$Bool)
  requires acc(MemoryBlock(target_address, Size$Bool$()), write)
  ensures acc(MemoryBlock(target_address, Size$Bool$()), write)
  ensures MemoryBlock$bytes(target_address, Size$Bool$()) ==
    to_bytes$Bool(source_snapshot)


method write_place_constant$Bool(target_place: Place, target_root_address: Address,
  source_snapshot: Snap$Bool)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$Bool$()), write)
  requires valid$Snap$Bool(source_snapshot)
  ensures acc(OwnedNonAliased$Bool(target_place, target_root_address, source_snapshot), write)
{
  write_address_constant$Bool(compute_address(target_place, target_root_address),
    source_snapshot)
  fold acc(OwnedNonAliased$Bool(target_place, target_root_address, source_snapshot), write)
}

method write_place_constant$Tuple$$$(target_place: Place, target_root_address: Address,
  source_snapshot: Snap$Tuple$$$)
  requires acc(MemoryBlock(compute_address(target_place, target_root_address),
    Size$Tuple$$$$()), write)
  requires valid$Snap$Tuple$$$(source_snapshot)
  ensures acc(OwnedNonAliased$Tuple$$$(target_place, target_root_address, source_snapshot), write)
{
  memory_block_split$Tuple$$$(compute_address(target_place, target_root_address),
    write)
  fold acc(OwnedNonAliased$Tuple$$$(target_place, target_root_address, source_snapshot), write)
}